<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
<meta property="og:type" content="website">
<meta property="og:title" content="周弈帆的博客">
<meta property="og:url" content="https://zhouyifan.net/index.html">
<meta property="og:site_name" content="周弈帆的博客">
<meta property="og:description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="周弈帆的博客">
<meta name="twitter:description" content="A foresighted strategist with big-picture thinking. 大局观选手。">






  <link rel="canonical" href="https://zhouyifan.net/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>周弈帆的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">周弈帆的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2020/01/11/Software-Engineering-course-review-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/11/Software-Engineering-course-review-1/" class="post-title-link" itemprop="url">软件工程复习1：结构化编程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-01-11 22:06:04" itemprop="dateCreated datePublished" datetime="2020-01-11T22:06:04+08:00">2020-01-11</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/Software-Engineering/" itemprop="url" rel="index"><span itemprop="name">Software Engineering</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我还剩软件工程这门课要考。这门课没留下真题，直接复习很难定下具体的目标。于是我决定还是用写复习笔记来复习，让复习的目的性更强，同时激发斗志，收获成就感。</p>
<p>软件工程这门课的性质十分特殊。这是一门几乎不涉及理论，却涉及工具的使用、大量的经验与人为设定的规则的一门课。讲得清楚一些，就是这门课几乎没有什么干货，应该更多地考察实践能力，而不是用靠着一张瞎记瞎理解就能回答的卷子来考察。但没办法，我纵使有着极为丰富的项目经验教训与软件工程方法实践心得，平时学这门课的时候也还算认真，考前还是不得不去做一下复习。</p>
<p>吐槽完了，来谈一下具体的复习策略。课本无效内容较多，每一章的有效内容量分布不均，最气人的是复习大纲和课本还对应不起来。没办法，我只能自己把这门课讲的内容分个类，针对每个类的内容集中复习。</p>
<p>从实际的编程方法来看，这门课讲了结构化编程和面向对象编程两种编程方式。这两种编程方式有着不一样的分析和设计方法、工具。因此，我会各用一篇文章来复习这两部分的方法和工具。此外，还有不少内容和具体的编程方法无关，比如软件测试、软件维护，这些内容我会用一篇文章来复习。还有一些比较细致的，略有理论性的东西，比如耦合的分类等内容，我单独用一篇文章来写这些理论知识。最后我对照复习大纲，扫干净剩下的知识点。</p>
<h1 id="软件工程复习1：结构化编程"><a href="#软件工程复习1：结构化编程" class="headerlink" title="软件工程复习1：结构化编程"></a>软件工程复习1：结构化编程</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>结构化需求分析的核心的数据。围绕着数据，要建立三种模型：数据建模、功能建模、行为建模。三种模型有各自的建模工具，三种模型中涉及的概念会被统一写在数据字典中以方便查看。</p>
<h3 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h3><p>数据建模描述的是数据的静态信息。准确来说，是一个数据可以进一步被分解成哪些属性，以及一个数据和另一个数据的关系中出现的新属性。</p>
<p>数据建模使用的E-R图。矩形是实体，圆圈是实体的属性，菱形是实体间的关系。有关系的实体要写上是几对几关系。</p>
<p>E-R图在上学期学数据库的时候学了，我就不多加复习了。只要看了E-R图的一个例子，就能很快搞懂这个图的意义与使用方法。</p>
<h3 id="功能建模"><a href="#功能建模" class="headerlink" title="功能建模"></a>功能建模</h3><p>理论上来说，有了静态模型，剩下的应该是动态模型。我对剩下两种模型的理解是：功能模型是对数据整体处理方式的建模，行为建模是对数据局部具体处理方式的建模。</p>
<p>所有程序全部可以看成是一个输入转换成输出的过程。输入输出不仅是传统的数据，输入可能是鼠标的一次点击、键盘的一次输入；输出可能是屏幕窗口的一个变化。功能建模就是描述输入数据是怎么一步一步变成输出数据的。</p>
<p>数据流图（DFD）是常用的（考试考察的）功能建模工具。DFD按照自顶向下的思想，用多层图来逐步分解数据加工过程。顶层图只有一个数据加工过程，之后的1、2层图会把上一层的数据加工过程细分。</p>
<p>每一层中，圆圈表示数据加工；矩形表示外部的实体，也就是和数据交互的对象；封了半边口的矩形是数据库；箭头是数据流向，箭头上要有数据流名。</p>
<p>DFD有以下要求：</p>
<ul>
<li>父图和子图要平衡。具体来说，父图和子图的输入输出要一致。子图可以把父图的输入分解。</li>
<li>数据变换部分要按次序编号</li>
</ul>
<p>这种图看了一遍例子就能理解图的意思，但要自己画一画才能掌握画的方法。正常来说DFD至少要分解到第二层，但考试要求我们只画一层。为了复习，我来做一道例题。</p>
<p>&lt;/br&gt;</p>
<p>例：银行活期现金存取款柜台业务软件系统。存款时，储户将存款金额及存折，交给银行柜台操作员；取款时，储户则直接将取款数额告知操作员，并递交存折。具体存取款过程如下：</p>
<p>  (1) 存款处理</p>
<ul>
<li>清点现金，确认存款金额；</li>
<li>输入帐号、存款金额；</li>
<li>根据存款金额记录分户账及总账，并登记存折及打印凭条。</li>
</ul>
<p>（2）取款处理</p>
<ul>
<li>输入帐号，取款金额；</li>
<li>储户输入密码，系统核对密码并查询余额；</li>
<li>若余额充足，根据取款金额记录分户账及总账，并由票据打印机打印登折数据和凭条数据。</li>
</ul>
<p>&lt;/br&gt;</p>
<p>要求：画出系统顶层和一层数据流图 。</p>
<p>老师给的参考答案：</p>
<p><img src="//zhouyifan.net/2020/01/11/Software-Engineering-course-review-1/DFD1.jpg" alt="DFD1"></p>
<p>我第一遍的答案：</p>
<p><img src="//zhouyifan.net/2020/01/11/Software-Engineering-course-review-1/DFD2-1.jpg" alt="DFD2-1"></p>
<p><img src="//zhouyifan.net/2020/01/11/Software-Engineering-course-review-1/DFD2-2.jpg" alt="DFD2-2"></p>
<p>看了答案后修改的答案：</p>
<p><img src="//zhouyifan.net/2020/01/11/Software-Engineering-course-review-1/DFD2-3.jpg" alt="DFD2-3"></p>
<p>先声明一下，这道题我们之前上课做了一遍，我不是第一次做。</p>
<p>首先先看一下顶层图，顶层图其实就是这个系统包含的范围，以及系统涉及的实体。把存折给操作员等行为并不是在软件中，因此不能放进软件系统里；打印机是一个独立的系统，不算在这个软件里面。所以最终顶层图画成了那个样子。我对顶层图答案没什么异议。</p>
<p>重点在一层图上。我这次第一遍画的时候，看到需求很明确地把软件的需求分成了存款和取款两个部分，所以我直接就分了两个数据变换模块，没有去管存取款的实现细节。讲道理，一层图不需要画那么细，这样画一样理论上就可以了。</p>
<p>但我看了答案之后，加入了一个信息记录模块。因为把修改分户账和总账在存款和取款中都出现了，单独拿出来也说得过去。</p>
<p>但是答案剩下的部分我就不能赞同了。首先是业务确认模块。需求只提到存款要确认，但没有提到取款要确认。虽然按常识来说存取款都是要确认操作的，但是这里需求没有给出，就不应该加进来。既然取款不需要确认，那么就不能写一个公共的业务确认模块。再来是查询余额模块。查询余额显然是属于取款的，这个应该属于实现细节，在一层图就写出来还早了一点。</p>
<p>老师上课的时候也跟我们说，由于只要求画一层图，这张图细节部分写得多了一些。按理来说，参考答案做的并不是很好。我觉得我第二遍的答案更好一些。甚至在实际实现的时候，我觉得第一遍的答案就够了，细节就应该在之后的图里显示出来。哪怕存取款有重合的部分，也可以在实现的时候进行模块复用。</p>
<p>我觉得这道题的最大启示不是一层图该如何分解，而是顶层图如何划分软件系统的边界的。我上课第一次画的时候就把递存折写进系统，而且没有画打印机，这些都是很明显的错误。当然我不知道考试的题会怎么出，应该把题目涉及的实体和数据变换模块找出来，把每一个重要的词都画进系统里应该就问题不大。</p>
<h3 id="行为建模"><a href="#行为建模" class="headerlink" title="行为建模"></a>行为建模</h3><p>前面也提到了，我觉得行为建模就是对更具体的数据变换过程进行建模。课本上介绍了两种建模方法：状态转换图（STD）和过程描述语言（PDL）或伪码语言（PL）。</p>
<h4 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h4><p>正如其名，状态转换图描述了数据对象不同时刻的不同属性，以及在不同状态间的转换方式。</p>
<p>我先以个人经验讲一下状态转换图的必要性。我之前做游戏的时候，被一个逻辑搞得十分头疼：卡牌游戏中鼠标的控制逻辑。正常情况下，鼠标可以拖动卡牌，也可以放到敌人头上或者一个buff上查看具体信息。在拖一张卡的时候，卡移到我方头上或者对方头上就不能显示信息，而应该根据卡牌是否能对这个目标使用而高亮目标。拖手牌里的一张卡和拖场面上的一张卡的拖动状态还是不一样的。由于没有事先设计，这个逻辑写的我非常混乱。我一看到了状态转换图，就立刻知道了以后该怎么处理这种状态转换情况。课本上再栩栩如生的案例也不如一次个人的经历对我理解这个概念的帮助大。</p>
<p>状态转换图就类似自动机，是一个点和边构成的图。点是状态，边是转移条件。在STD中，黑点代表初态，带圈黑点表示终态，大圆角矩形框表示中间状态。中间状态要写上状态名、状态变量、状态此时的活动。</p>
<p>状态转移图我还没画过，虽然考试不一定会考怎么画，但我还是想练习一下。</p>
<p>我画的时候发现visio的状态图和课本上的不太一样，就不打算画了。</p>
<h4 id="加工逻辑"><a href="#加工逻辑" class="headerlink" title="加工逻辑"></a>加工逻辑</h4><p>加工逻辑就是描述流程或算法。工具就是我们非常熟悉的伪代码。</p>
<p>伪代码理论上没什么格式要求。我喜欢按C语言的风格写。当然有些人喜欢拿箭头表示赋值。</p>
<h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><p>数据字典就是对之前建模过程中的数据流、数据变换、数据做一个详细的定义，以方便沟通交流。</p>
<p>数据字典本身是一个概念性质的东西，其实现形式多种多样。课本上讲了三种定义数据字典的方法。</p>
<h4 id="词条描述"><a href="#词条描述" class="headerlink" title="词条描述"></a>词条描述</h4><p>非常死板非常麻烦的数据词典表示法，也许在实际运用中非常好用，因为它读起来的时候非常详细。但在学这门课的时候我是不愿这样写数据字典的。</p>
<p>直接拿一个例子来讲词条描述的表法吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数据元素名：词</span><br><span class="line">类型：文字（char*)</span><br><span class="line">长度：任意长度</span><br><span class="line">取值范围：………………</span><br><span class="line">相关数据元素：………………</span><br><span class="line">相关数据结构：字符型（不能为空）</span><br></pre></td></tr></table></figure>
<h4 id="定义式"><a href="#定义式" class="headerlink" title="定义式"></a>定义式</h4><p>用一种类似上下文无关语言的方法来定义一种数据。还是直接上例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">日期 = 年 ＋　月　＋日</span><br><span class="line">年 = “1900”..&quot;1999&quot;</span><br><span class="line">月 = &quot;01&quot;..&quot;12&quot;</span><br><span class="line">日 = &quot;01&quot;..&quot;31&quot;</span><br></pre></td></tr></table></figure>
<h4 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h4><p>直接把数据库二维表当成数据字典。比如</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编号</th>
<th>属性</th>
<th>英文名</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>姓名</td>
<td>Name</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h2 id="结构化设计"><a href="#结构化设计" class="headerlink" title="结构化设计"></a>结构化设计</h2><p>设计分成概要设计和详细设计。这两个阶段的具体定义可能会在其他文章中讲。</p>
<p>在结构化设计中，概要设计就是根据数据流图设计出整体结构，详细设计则是在语句层面具体设计某一个算法、过程。概要设计用面向数据流的设计方法，详细设计会用到流程图、盒图、问题分析图（PAD）、判定树。</p>
<h3 id="面向数据流的设计方法（画结构图）"><a href="#面向数据流的设计方法（画结构图）" class="headerlink" title="面向数据流的设计方法（画结构图）"></a>面向数据流的设计方法（画结构图）</h3><p>面向数据流的设计方法就是根据需求分析时的数据流图，设计出程序的模块。和画DFD一样，这个过程也是自顶向下进行的。</p>
<h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p>这个过程用到的工具有层次图和结构图（SC）。但从课本上的介绍来看，结构图是层次图的一个拓展。也就是这两种图不是并列关系，而是递进关系。后续的分析也是基于结构图的。</p>
<p>层次图用方框表示模块，只是把模块一层一层地越分越细。结构图在层次图的基础行，要求在模块之间的线上加上数据流的描述</p>
<h4 id="数据流图转结构图"><a href="#数据流图转结构图" class="headerlink" title="数据流图转结构图"></a>数据流图转结构图</h4><p>数据流图经过很简单的转换就能变成结构图。课本介绍了两种转换方法。这两种方法输出的结构图的整体结构与大致算法大致相同，但分析数据流图的理解角度不同。</p>
<p>第一种方法是变换分析法。这种方法把整个程序看成输入处理、输出处理、变换控制三个大模块。在一层数据流图中，根据数据流与变换的形状关系，把变换分进这三种大模块里。每一个变换属于大模块里的一个小模块。</p>
<p>用这种方法画结构图要按以下步骤：首先，画一个主控模块（MC）、输入模块（MI）、输出模块（MO），变换控制模块（MT）。MC在最上面，MI、MT、MO分别画在下面，与MC连线。之后，再一层数据流图中画两条边界，把一层图分成三部分。最后，把数据流图“旋转”一下，把对应的数据流和变换模块都写到大模块下方。只要有了数据流图，划分了边界，就可以立刻把数据流图转换成结构图。看了书上的例子就能很快理解这个转换方法。</p>
<p>第二种方法是事物分析法。该方法是思想是找到一层数据流图中有多条路径的变换，把这个变换当成事务中心。所有的输入在经过预处理后经过事物中心进行变换，没有输出模块。</p>
<p>用这种方法画结构图有以下步骤：首先，在一层数据流图中找到事物中心，把事物中心的输入部分划分到一起。之后，画一个主控模块（MC）、输入模块（MI）、事物调度模块（该模块名就是选择的事务中心的变换名）。最后，用和变换分析法类似的方法把数据流图“旋转”一下，在大模块下补上小模块。</p>
<p>当然还有第三种方法，叫混合分析法，就是把两种方法综合一下，变换分析法的输出模块改成事物调度模块。</p>
<h3 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h3><p>这是高中就学过的工具，用以描述程序设计的三种结构（顺序、分支、循环）。</p>
<p>圆矩形表示开始结束，方矩形表示是操作，菱形表示判断，箭头表示控制流方向。</p>
<h3 id="盒图"><a href="#盒图" class="headerlink" title="盒图"></a>盒图</h3><p>盒图也是用来描述程序设计的。相比程序流程图，盒图没有随意的控制流，能够更好地划分数据的区域。</p>
<p>整个盒图画在一个方形中。具体形式看后面的示例。</p>
<h3 id="问题分析图"><a href="#问题分析图" class="headerlink" title="问题分析图"></a>问题分析图</h3><p>问题分析图（PAD）也是用于程序设计的图。它也能规避控制流的任意性。</p>
<p>PAD从上到下是流程，从左到右是模块的细分。</p>
<p>例：</p>
<p>把代码转换成盒图和PAD。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">A;</span><br><span class="line">B;</span><br><span class="line">if (C1)</span><br><span class="line">&#123;</span><br><span class="line">	while (C2)</span><br><span class="line">	&#123;</span><br><span class="line">		if (C3)</span><br><span class="line">		&#123;</span><br><span class="line">			D;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			E;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		F;</span><br><span class="line">		if (C4)</span><br><span class="line">		&#123;</span><br><span class="line">			G;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			H;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while (C5);</span><br><span class="line">&#125;</span><br><span class="line">if (C6)</span><br><span class="line">&#123;</span><br><span class="line">	I;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（原题来自课本的一个流程图）</p>
<p>解：</p>
<p><img src="//zhouyifan.net/2020/01/11/Software-Engineering-course-review-1/NS.jpg" alt="NS"></p>
<p><img src="//zhouyifan.net/2020/01/11/Software-Engineering-course-review-1/PAD.jpg" alt="OAD"></p>
<h3 id="判定树"><a href="#判定树" class="headerlink" title="判定树"></a>判定树</h3><p>判定树用来表述复杂的条件判断。由于if语句本身符合树结构，用一棵树来表示判断语句是非常自然的。</p>
<p>判定树画起来很简单，左边是条件，每个条件都可以分叉成多个子情况里的条件。最右边是该分支下的结构。</p>
<h3 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h3><p>判定表和判定树作用一样，也是设计复杂条件判断的工具。</p>
<p>判定表的行分成两部分，一部分是条件，另一部分是动作。判定表的每一列表示一个条件和动作的组合情况（条件用T、F表示，执行的动作打个勾）。</p>
<h1 id="一些后续的事情"><a href="#一些后续的事情" class="headerlink" title="一些后续的事情"></a>一些后续的事情</h1><p>由于我没有管理好精力，我没有对后面几章做系统的复习。还好，考试没有考很多死板的内容，考的东西偏向理解，我几乎都能答得上来。有一点要特别提一下：考前说好数据流图只画一层，考试的时候要求画两层。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2020/01/09/Principles-of-Computer-Composition-exam-result/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/09/Principles-of-Computer-Composition-exam-result/" class="post-title-link" itemprop="url">计算机组成原理考试结果</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-01-09 18:59:00" itemprop="dateCreated datePublished" datetime="2020-01-09T18:59:00+08:00">2020-01-09</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Talk/" itemprop="url" rel="index"><span itemprop="name">Talk</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机组成原理考试结果"><a href="#计算机组成原理考试结果" class="headerlink" title="计算机组成原理考试结果"></a>计算机组成原理考试结果</h1><p>和写论文一样，讲完了方法以后，要展示一下实验的结果。我在运用了带有周弈帆特色的费曼学习法进行计算机组成原理的复习后，也要讲一下考试的结果，以佐证方法的高效性。</p>
<p>考试前天结束，现在考试的分数还没出。我先从我自己的感觉谈一下考试的结果和收获。考试分数结果等出了分再更新。</p>
<h2 id="个人感觉结果"><a href="#个人感觉结果" class="headerlink" title="个人感觉结果"></a>个人感觉结果</h2><p>考试考察的知识点果然全是复习PPT里的。复习PPT里用红字标出的内容全部出了题目。很不幸，我没有把复习PPT涉及的细琐知识点都过一遍，填空有3题左右完全没听过，选择有1题完全没听过。但我对剩下的题目涉及的知识点非常熟悉，解起题来十分顺畅。说实话，在这门课里我学到的东西并不多。但我也不搞硬件。我认为我在这门科目上的学习成果符合我对自己的要求，也符合学校对学生们的要求。</p>
<p>从复习时间安排上来评价我这次考试。学校所有课程结束后，我剩下了3天时间复习。虽然第一天我没有调整好生物钟，昏昏沉沉地过去了。但在接下来的两天半里（考试是下午考），我快马加鞭，聚精会神地进行复习。把对每章知识点的熟悉程度提升回写那一章作业时的程度。最终，虽然有些小赶，时间略显窘迫，但我还是比较完整地复习了所有内容。我在时间安排上虽有失误，却亡羊补牢，为时未晚。</p>
<p>从复习方法上了评价我这次考试。我和以前一样，用的是费曼学习的思想，也就是用自己的话去描述知识，从而找到理解的漏洞。其实我之前概率论和计算理论也是用了这种方法，但效果不佳。概率论那次应该是我对知识本来就比较熟悉，不应该重新理解知识，而应该做题巩固知识的理解；计算理论那次我只写了一章，实在太累了没有接着写下去。我坚信不是方法有问题，而是我之前做得不够好，所以这次依然采用了这种复习法。恰好，计算机组成原理考试强调知识的基本理解而不强调知识的熟练应用，这种复习法完美契合了考试的要求。我也坚持了下来，把主要章节都做了一次复习。可以说这次考试方法选择得非常恰当。不过话说回来，我似乎也没有发明出第二种复习方法，好像“选择”一词并不恰当。但是，用这个词更帅一些。</p>
<p>从复习策略上里评价我这次考试。我既没有像无头苍蝇一样，拿着课本乱翻乱看；又没有像复读机一样，逐字逐句地去从干巴巴的课本中背下每一句话。我去学校网站上下载了考试复习的PPT，非常精准地命中了大部分的会考到的知识点。与此同时，对于我上课的时候理解过一遍的知识点，以及每次课后作业所涉及的知识点，我又认真地复习了一遍。可谓是双管齐下，两手都抓，两手都硬。最终，虽然算有遗策，但大局难改，考试的大部分题目对我来说就像小学数学一般简单。在有限的时间里完成复习，复习策略的正确选择是成功的关键。</p>
<p>虽然考试结果没出，虽然我可能惨遭打脸，但我依然敢于给自己下断言：我这门学科成绩85起步，封顶95。</p>
<p>如果最终成绩有所偏差，那么我也不亏。在学这门课的时候，我学到了课本内的知识，培养了课本外的学习能力。分数不能代表一切。你若是只看分数，你就输了。要看到分数之外的东西。</p>
<p>希望二月出成绩后，我能看到一个比较好的结果。</p>
<h2 id="考试结果"><a href="#考试结果" class="headerlink" title="考试结果"></a>考试结果</h2><p>最后我考了88分。没考到90分满绩还是有点遗憾的。</p>
<p>考试的结果证明这次的整体复习效果确实还可以，但是由于时间不足的原因，我没有仔细去看每一个知识点，这些细琐的知识点应该是我失分的地方。</p>
<p>我不希望以后再出现这种考试，所以我就不写我以后应该怎么怎么做了。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2020/01/07/Principles-of-Computer-Composition-cources-review-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/07/Principles-of-Computer-Composition-cources-review-6/" class="post-title-link" itemprop="url">计算机组成原理复习：第六章 中央处理器</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-01-07 02:56:49" itemprop="dateCreated datePublished" datetime="2020-01-07T02:56:49+08:00">2020-01-07</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/Principles-of-Composition/" itemprop="url" rel="index"><span itemprop="name">Principles of Composition</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>去百度查课后答案的时候，发现这本教材至少11年没有发生改动。虽然这本书涉及都是一些原理性的东西，和时代无关。真要说起来，这门课对我们来说也不过是一门学过就忘的课。但我还是觉得这种教学态度有问题，需要加以改正。</p>
<h1 id="计算机组成原理复习：第六章-中央处理器"><a href="#计算机组成原理复习：第六章-中央处理器" class="headerlink" title="计算机组成原理复习：第六章 中央处理器"></a>计算机组成原理复习：第六章 中央处理器</h1><p>本章主要在讲CPU（中央处理器）。本章先整体介绍了CPU的组成结构、性能参数等内容，之后稍微介绍了CPU的硬件实现，再具体介绍了CPU的整个控制工作原理。由于CPU执行指令的时候涉及一些微操作，本章接着又进一步介绍了微操作的有关内容。介绍完了CPU的基本工作原理后，本章又介绍了一个简单CPU应支持的操作。最后本章介绍了CPU相关的新技术。</p>
<p>CPU实际上包括运算器和控制器。运算器主要涉及的计算方法在之前章节已经介绍过。这一章实际的重点是控制器的实现。</p>
<p>考试重点应该是放在对CPU执行指令的过程和微操作的原理上。要理解CPU指令的执行过程，对于一个给定的操作，要能够写出CPU每一步在做什么。</p>
<p>和上一章一样，我只对比较重点的地方进行复习。</p>
<h2 id="CPU的基本组成"><a href="#CPU的基本组成" class="headerlink" title="CPU的基本组成"></a>CPU的基本组成</h2><p>其实CPU的组成主要是讲CPU里有哪些寄存器。寄存器可以分成通用和专用。专用的寄存器是只有固定用途的寄存器，而通用寄存器可以根据实际需要使用。可以看成预定义常量和变量，或是操作系统中的系统内存和用户内存。</p>
<p>专用寄存器有：</p>
<ul>
<li>程序计数器PC</li>
<li>指令寄存器IR</li>
<li>存储器数据寄存器MDR</li>
<li>存储器地址寄存器MAR</li>
<li>程序状态字寄存器PSWR</li>
</ul>
<p>这里只是提一下这些寄存器的名字，后面讲CPU的控制原理的时候还会提到这些寄存器，到那个时候才能理解这些寄存器在干什么。这里提一下就当是在声明变量。</p>
<p>处理寄存器外，CPU中还有一个指令译码器IR，用于识别指令中的操作码。还有一个控制单元CU，大名叫微操作信号发生器。它是CPU控制功能的核心。</p>
<p>CU的实现方式在复习PPT中被列成了重点，我不得不看了一下。CU的实现大致分两种，组合逻辑控制器和微程序控制器。其实控制的微操作和程序设计一样，也是模块化的。组合逻辑控制器追求速度，却无法拓展，难以调试，难以实现自动化设计。微程序控制器的特点与之相反。（我没搞懂什么是自动化设计）</p>
<p>除了这些外，CPU中还有ALU，但这不是本章的重点。</p>
<h2 id="时序系统"><a href="#时序系统" class="headerlink" title="时序系统"></a>时序系统</h2><p>时序系统是CPU的工作基础。和游戏一样，CPU的工作也有基本的时间单位。这种和最小时间单位有关的系统就是时序系统。</p>
<p>这里自顶向下地介绍整个时序系统。指令周期是指从取指令、取数到完成指令整个过程需要的时间。各种指令所需的指令周期不同。指令周期会拆成机器周期（CPU）周期，每个机器周期干一个特定的活，比如取值周期、取数周期。机器周期又要完成若干微操作，每个微操作占用的时间叫做节拍。每个节拍最终由几个脉冲组成。脉冲是最小的时间单位。</p>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><p>这一部分是CPU控制原理的核心。</p>
<p>指令执行过程分成三个阶段：取指令阶段、分析取数阶段和执行阶段。</p>
<h3 id="取指令阶段"><a href="#取指令阶段" class="headerlink" title="取指令阶段"></a>取指令阶段</h3><p>从宏观上来讲，这一阶段把指令从主存中取出来并存到指令寄存器中。具体来说分以下几步：</p>
<ol>
<li>(PC)-&gt;MAR</li>
<li>CU向存储器发读命令 Read</li>
<li>取出的指令存到MDR中 M(MAR)-&gt;MDR</li>
<li>把MDR的内容送到IR中 (MDR)-&gt;IR</li>
<li>PC自增 (PC)+1-&gt;PC</li>
</ol>
<h3 id="分析取数阶段"><a href="#分析取数阶段" class="headerlink" title="分析取数阶段"></a>分析取数阶段</h3><p>根据指令，取操作数。由前几章的内容可知，指令中的操作数可能表达得十分“晦涩”，可能要通过多次间接寻址才能得到。</p>
<p>如果操作数不用寻址，那么就不用进行此阶段。</p>
<p>比如要取@R0，即以R0的值为地址，到主存中取数。那么操作有以下几步：</p>
<ol>
<li>(R0)-&gt;MAR</li>
<li>Read</li>
<li>M(MAR)-&gt;MDR</li>
</ol>
<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>现在我们有了函数，有了函数参数，接下来的任务就是执行指令并将结果保存。</p>
<p>比如把数相加的执行阶段指令有以下几步（MAR已经是目标存储寄存器的地址）：</p>
<ol>
<li>(R1)+(Y)-&gt;Z</li>
<li>(Z)-&gt;MDR</li>
<li>Write</li>
</ol>
<p>比如转移A步指令的执行阶段有以下几步：</p>
<ol>
<li>(PC)-&gt;Y</li>
<li>Ad(IR) + (Y) -&gt; Z</li>
<li>(Z)-&gt;PC</li>
</ol>
<h2 id="微程序原理"><a href="#微程序原理" class="headerlink" title="微程序原理"></a>微程序原理</h2><h3 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h3><p>之前CPU执行的每一步操作，都叫做微操作。对于指令来说，这些微操作都是不可再分的操作。但是从微操作的角度来看，微操作还可以分成很多个更细致的操作，比如打开某个逻辑门等。这些更细致的操作叫微命令。不同的微操作之间可能会公用相同的微命令。引入程序设计的思想，微命令的重用和模块化非常关键。微程序控制的思想也因此被提出来了。</p>
<p>一个机器指令就对应一个微程序。一个微程序里可以分成多个微指令，微指令就是一个一个函数。和CPU的指令类似，微指令也分为操作码和地址码。但微指令的地址码只包括下一条要执行的微指令的地址，而不是存数据的地址。在微指令中，微命令就是原子操作，和程序中的语句相同。</p>
<h3 id="微指令编码"><a href="#微指令编码" class="headerlink" title="微指令编码"></a>微指令编码</h3><p>微指令编码指对微指令的操作码编码。操作码译码的结果是得到一个01序列，表示执行哪些微命令。</p>
<p>最显然的两种编码法是直接编码法和最短编码法。前者令操作码每一位都表示一个微命令是否执行，后者进行完全编码，每次只能产生一个微命令的输出。由于微命令可以并行，但又不是每种操作都能并行，因此第一种方法编码长度过长，而第二种方法无法进行并行。</p>
<p>一种折衷二者的方案是：事先知道哪些操作不能并行，把这些操作分成一组，进行完全编码。整个操作码就被分成了一个一个完全编码的字段。</p>
<p>课后有一道这方面的题目。考试估计会考。</p>
<h3 id="组成部件"><a href="#组成部件" class="headerlink" title="组成部件"></a>组成部件</h3><ul>
<li>控制存储器CM，存了一堆微程序</li>
<li>μIR，微指令寄存器，和IR类似</li>
<li>微地址形成部件，用于形成初始微地址和后续微地址</li>
<li>μMAR，微地址寄存器，和MAR类似，但不是从内存而是从CM中取指令</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2020/01/07/Principles-of-Computer-Composition-cources-review-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/07/Principles-of-Computer-Composition-cources-review-5/" class="post-title-link" itemprop="url">计算机组成原理复习：第五章 存储系统和结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-01-07 01:28:55" itemprop="dateCreated datePublished" datetime="2020-01-07T01:28:55+08:00">2020-01-07</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/Principles-of-Composition/" itemprop="url" rel="index"><span itemprop="name">Principles of Composition</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>比较可惜的是，从这章开始，这门课的内容就讲得很不细致了。很多内容只能从一个很高的层次进行介绍，无法深入细节。一旦讲到了偏硬件的东西，由于难以进行实践，又和数学等理科知识关系不大，和电路等学科关系密切，课本就只能划水。</p>
<h1 id="计算机组成原理复习：第五章-存储系统和结构"><a href="#计算机组成原理复习：第五章-存储系统和结构" class="headerlink" title="计算机组成原理复习：第五章 存储系统和结构"></a>计算机组成原理复习：第五章 存储系统和结构</h1><p>本章先从整体上介绍了计算机的存储结构，再着重介绍主存的存储思想以及具体的主存种类。之后讲了多个主存储器是如何构成一个系统的。最后稍微介绍了一些其他cache、虚拟内存等内容。</p>
<p>我只针对复习PPT提到的重点和我们课后习题涉及到的内容进行复习。</p>
<h2 id="主存储器的组织"><a href="#主存储器的组织" class="headerlink" title="主存储器的组织"></a>主存储器的组织</h2><p>这一节围绕主存是如何存储数据的，介绍了主存储器整体的工作原理，和前面编码的内容有一些关联。主存储器本身的结构在后面的小节里介绍。</p>
<h3 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h3><p>数据的最小单位是位，被叫做<strong>存储位</strong>。按位存取效率太低，多个存储位在一起就成了<strong>存储字</strong>，这是访问的最小单元。存存储字的结构叫<strong>存储单元</strong>，地址和存储单元是一一对应的。大量存储单元构成了<strong>存储体</strong>。</p>
<h3 id="主存部分技术指标"><a href="#主存部分技术指标" class="headerlink" title="主存部分技术指标"></a>主存部分技术指标</h3><h4 id="存取时间"><a href="#存取时间" class="headerlink" title="存取时间"></a>存取时间</h4><p>执行一次读或写操作的时间。</p>
<h4 id="存取周期"><a href="#存取周期" class="headerlink" title="存取周期"></a>存取周期</h4><p>两次执行访问操作的间隔时间。因为除了完成存取操作外，主存内部还有一些其他的操作，存取周期一般略大于存取时间。</p>
<h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>等于主存等效工作频率乘主存位宽。</p>
<h3 id="数据在主存的存放"><a href="#数据在主存的存放" class="headerlink" title="数据在主存的存放"></a>数据在主存的存放</h3><p>可能出现主存的存储字长比较大，而计算机传来的数据比较小的情况。比如主存的存储字长是64位，而计算机传来的数据可能是8~64位的。如何存这些数据是一个问题：</p>
<p>如果每个数据紧挨着存，那么主存空间没有浪费。但是万一一个存储字剩余容量较小，突然来了一个64位数据，那么这个数据就得拆成两半，存在两个存储字里了。</p>
<p>如果每个数据都存在一个存储字里，那就太浪费了。如果所有数据都是一个字节，那么大量的空间要被浪费。</p>
<p>因此，边界对齐的存取法被提出。这种方法综合了以上两种方法的优点。比如，在存储字为64位的主存储器里，64位数据只能从一个存储字开头从，32位数据只能从半个存储字开头存，16位位数据只能从四分之一个存储字开头存。</p>
<h2 id="主存储器结构与工作原理"><a href="#主存储器结构与工作原理" class="headerlink" title="主存储器结构与工作原理"></a>主存储器结构与工作原理</h2><p>这一节前面讲了很多和电路的东西，我们缺乏基础知识，学不懂。我只复习DRAM的刷新以及RAM芯片的一些参数。</p>
<h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h3><p>由于DRAM电路的问题，需要经常刷新才能维护数据。</p>
<p>注意，刷新是指对每个芯片的刷新。芯片一般会排成正方向阵列，比如16K的芯片，就会排成128*128。之后谈到的按行刷新，这个“行”指的就是128。刷新就等于读了一遍，因此刷新周期等于读写周期。这个刷新周期是以行为单位的。</p>
<p>为了提高整体的工作效率，有几种不同的刷新策略：</p>
<h4 id="集中刷新"><a href="#集中刷新" class="headerlink" title="集中刷新"></a>集中刷新</h4><p>在最大允许的刷新间隔内，把工作分成两个阶段：读写操作和刷新。在所有读写操作执行一段时间后，集中刷新所有的存储芯片，再继续读写。等于说每个刷新间隔构成了一个循环的工作周期。</p>
<h4 id="分散刷新"><a href="#分散刷新" class="headerlink" title="分散刷新"></a>分散刷新</h4><p>每次读或写之后，立刻刷新。也就是读写操作和刷新绑定。这样可以保证内存正常，但是刷新过于频繁，读写周期变长，没有充分利用最大允许刷新间隔</p>
<h4 id="异步刷新"><a href="#异步刷新" class="headerlink" title="异步刷新"></a>异步刷新</h4><p>异步刷新综合以上两种方法，把主存按行分组。先做一会儿读写操作，就停下来刷新第一行；再做一会儿读写操作，就刷新第二行……。在最大允许刷新间隔内，把所有行都刷新一遍。</p>
<p>课本上对以上三种方法都画了一个图，看了图就很好理解。</p>
<h3 id="RAM芯片引脚"><a href="#RAM芯片引脚" class="headerlink" title="RAM芯片引脚"></a>RAM芯片引脚</h3><ul>
<li>地址线</li>
<li>数据线</li>
<li>片选线 CS</li>
<li>读写控制线 WE</li>
<li>Vcc 电源</li>
<li>GND 地</li>
</ul>
<p>其中片选线的意思可能不能通过字面来理解。片选线决定该芯片是否工作。</p>
<p>上述引脚的字母打的不是很准确。这篇文章我不打算渲染公式，所以就简单写一下。</p>
<p>先复习一下这些引脚是因为之后的内容会用到。</p>
<h2 id="主存储器的连接与控制"><a href="#主存储器的连接与控制" class="headerlink" title="主存储器的连接与控制"></a>主存储器的连接与控制</h2><p>本节讲的是多个主存储器是如何协作的。</p>
<h3 id="主存储器扩展"><a href="#主存储器扩展" class="headerlink" title="主存储器扩展"></a>主存储器扩展</h3><p>存储芯片一般比较小。为了得到一个较大的主存储器，需要把存储芯片连接扩展。</p>
<p>先提一句，芯片用数据量和数据位数来表示。比如64K X 1就是地址64K，数据只有1位的芯片。</p>
<p>考试主要考察的就是画图。注意，一堆线要画成粗的线。箭头表示数据传输方向，数据线的箭头是双向的，其他线的箭头是单向的。</p>
<p>有以下三种扩展方法：</p>
<h4 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h4><p>用一堆地址一样的芯片扩展位数。</p>
<p>地址线、片选线并联进每一个芯片。</p>
<p>数据线每一根接一个芯片。</p>
<p>以64K X 1拓展到64K X 8为例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>芯片1</th>
<th>芯片2</th>
<th>芯片3</th>
<th>…</th>
<th>芯片8</th>
</tr>
</thead>
<tbody>
<tr>
<td>A0</td>
<td>——l——</td>
<td>——l——</td>
<td>——l——</td>
<td>——l——</td>
<td>——l——</td>
</tr>
<tr>
<td>…</td>
<td>——l——</td>
<td>——l——</td>
<td>——l——</td>
<td>——l——</td>
<td>——l——</td>
</tr>
<tr>
<td>A15</td>
<td>——l——</td>
<td>——l——</td>
<td>——l——</td>
<td>——l——</td>
<td>——l——</td>
</tr>
<tr>
<td>CS</td>
<td>——l——</td>
<td>——l——</td>
<td>——l——</td>
<td>——l——</td>
<td>——l——</td>
</tr>
<tr>
<td>D0</td>
<td>——l——</td>
<td>—————</td>
<td>—————</td>
<td>—————</td>
<td>—————</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>D7</td>
<td>—————</td>
<td>—————</td>
<td>—————</td>
<td>—————</td>
<td>——l——</td>
</tr>
</tbody>
</table>
</div>
<h4 id="地址扩展"><a href="#地址扩展" class="headerlink" title="地址扩展"></a>地址扩展</h4><p>假设一堆芯片位数相同，但存储量不够，可以把它们并在一起扩展地址</p>
<p>这种方法的思想是，地址线的高位用来片选，也就是选择使用那片芯片；低位直接输入芯片。</p>
<p>此处看书上的图很好理解。</p>
<h4 id="字和位同时扩展"><a href="#字和位同时扩展" class="headerlink" title="字和位同时扩展"></a>字和位同时扩展</h4><p>同时执行上面两种扩展。</p>
<p>看书上的图很好理解。</p>
<h3 id="存储芯片的地址分配与片选"><a href="#存储芯片的地址分配与片选" class="headerlink" title="存储芯片的地址分配与片选"></a>存储芯片的地址分配与片选</h3><p>上一节地址扩展中，出现了如何分配地址这个问题。上一节是用一个译码器来分配地址高位，得到片选结果。本节具体介绍了分配地址时存储芯片片选的方式。</p>
<h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h4><p>地址高位的每一位直接就代表是否选中某个芯片，而不经过移码。由于片选时0表示有效，因此用于片选的地址高位只能有一个0。</p>
<h4 id="全译码法"><a href="#全译码法" class="headerlink" title="全译码法"></a>全译码法</h4><p>就是上一节的方法，把高位输入译码器进行译码，输出选择哪一个芯片。有可能输入的地址组合量大于需要的量，比如输入9位，但只有4个芯片。这个时候译码结果只有4个是有效的，其他508个都是无效的。</p>
<h4 id="部分译码法"><a href="#部分译码法" class="headerlink" title="　部分译码法"></a>　部分译码法</h4><p>在全移码的基础上，只把部分位输入译码器。比如要选择4个芯片，只输入2位就行了。这样的话地址的高位完全用不到，会产生地址重叠。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2020/01/06/Principles-of-Computer-Composition-cources-review-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/06/Principles-of-Computer-Composition-cources-review-4/" class="post-title-link" itemprop="url">计算机组成原理复习：第四章 数值的机器运算</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-01-06 19:12:01" itemprop="dateCreated datePublished" datetime="2020-01-06T19:12:01+08:00">2020-01-06</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/Principles-of-Composition/" itemprop="url" rel="index"><span itemprop="name">Principles of Composition</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>和上一篇文章一样，这篇文章的很多内容是我学这门课的时候写的。</p>
<h1 id="计算机组成原理复习：第四章-数值的机器运算"><a href="#计算机组成原理复习：第四章-数值的机器运算" class="headerlink" title="计算机组成原理复习：第四章 数值的机器运算"></a>计算机组成原理复习：第四章 数值的机器运算</h1><p>本章讲了计算机电路是如何实现运算。计算机中的运算可以整体分成数值计算和逻辑计算。无论多复杂的数值操作，都可以用加减乘除来实现，因此本章讲了加减乘除四则运算的实现；逻辑运算是计算机运算的基础，本章也介绍了与、或、取反等逻辑运算。最后本章讲了运算器的一些具体实现。</p>
<p>进一步来划分一下本章的结构。减法运算是靠加法实现的，因此本章先重点介绍了加法器的实现，之后讲了如何用加法器来实现加法和减法。由于乘除操作基于加法和移位，因此本章之后介绍了移位操作的实现，再介绍了定点乘除操作的实现。如第二章所述，浮点运算实际上基于的是定点小数和定点整数，浮点的所有运算也可以由定点的计算转换而来，因此再之后本章才介绍了浮点数间的计算。十进制做为数值计算的一种特例，和之前内容的关系并不是很紧密，在所有基本运算的实现介绍完之后才介绍。运算部分结束后，本章又稍微提了一下逻辑计算，因为它太简单了。最后是一些在本课中价值不大的运算器的实现。</p>
<p>本章各节间的逻辑关系是非常紧密的，当你整理出本章的依赖关系后，一张依赖图就能出现在你的脑海中。可惜这里位置太小，我画不下。</p>
<p>说实话，我觉得本书这一章的部分内容更应该放到数字逻辑中去讲。这一章有不少涉及电路的知识，很多知识都属于学科间的边缘交界地带。但这一章后面又多了很多和具体电路无关，介绍电路实现算法的知识，这些知识放进计算机组成原理倒也没错。我觉得本书这一章结构编的不是很好，前面全加器的电路实现应该放到其他学科去，整章就介绍抽象的电路实现，没必要讲到电路的优化上，保持知识的深入程度相似。</p>
<h2 id="基本运算（加法）电路实现"><a href="#基本运算（加法）电路实现" class="headerlink" title="基本运算（加法）电路实现"></a>基本运算（加法）电路实现</h2><p>由于所有其他运算可以用加法来表示，所以加法被叫做“基本算数运算”。</p>
<h3 id="加法器简介"><a href="#加法器简介" class="headerlink" title="加法器简介"></a>加法器简介</h3><h4 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h4><p>输入$A_i$，$B_i$，进位$C_{i - 1}$，输出当前结果$S_i$和进位$C_i$。</p>
<p>具体原理在数字逻辑中已经学过了，用两个半加器就能实现。</p>
<h4 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h4><p>只有一个加法器，移位寄存器不断地把每一位放到全加器里计算。这种方法实在是太慢了</p>
<h3 id="并行加法器进位的产生与传递"><a href="#并行加法器进位的产生与传递" class="headerlink" title="并行加法器进位的产生与传递"></a>并行加法器进位的产生与传递</h3><p>由于并行加法器比较复杂，这里单独开了好几个小节来讲。</p>
<p>并行加法器就是把一堆全加器放在一行，上一个的进位输出放到下一个的进位输入里。数字逻辑中也学过了并行加法器。</p>
<p>并行加法器的问题在于，当前位做运算时，需要等待上一位运算完成，获取进位输入。因此，并行加法器看似结构上并行，实际上运算速度还要受到产生和传递进位的速度的影响。</p>
<p>为了想办法提高运算速度，本节分析了并行加法器进位的产生与传递的本质。</p>
<p>进位的表达式为：</p>
<p>$C_i=A_iB_i+(A_i \bigoplus B_i)C_{i - 1}$</p>
<p>其意思是，如果要产生进位，要么两个当前位都是1，要么是两个当前位有一个是1，且上一位有进位。</p>
<p>说实话，后面那个异或运算增加了理解的难度。明明那个异或写成或的话，这个式子也是成立的，读起来也更加清晰。不知道是不是异或门比或门更快的原因。老师和课本都没有对这里进行讲解。</p>
<p>为了方便后面的分析，用更简单的形式来写上面的式子</p>
<p>$C_i = G_i + P_iC_{i - 1}$</p>
<p>这个式子暗示$A_i,B_i$对后面的分析毫无影响，我们只关系进位间的关系。</p>
<h3 id="并行加法器进位的优化"><a href="#并行加法器进位的优化" class="headerlink" title="并行加法器进位的优化"></a>并行加法器进位的优化</h3><h4 id="并行进位法"><a href="#并行进位法" class="headerlink" title="并行进位法"></a>并行进位法</h4><p>根据之前的分析：</p>
<p>$C_1 = G_1 + P_1C_0$</p>
<p>$C_2 = G_2 + P_2C_1$</p>
<p>把第一个式子代入第二个式子得：</p>
<p>$C_2 = G_2 + P_2(G_1 + P_1C_0) = G_2 + P_2G_1 + P_2P_1G_0$</p>
<p>可以观察到，$C_1$消失了。只需要最初的$A_1,B_1,C_0$，就能直接得到第二位的进位，而不需要等待第一位的进位输入。</p>
<p>如果反复利用这种方式，那么无论是第几位的进位输出，都可以用初始的几个量算出来了。由于逻辑门是可以并行的，无论这个式子多长，只需要花费一次计算与的时间和一次计算或的时间就可以完成 进位输出的计算，时间复杂度是$O(1)$。设与门、或门的延迟时间位$ty$，那么这种方法耗费的时间是$2ty$。</p>
<p>顺带一提，之前要等待上一位进位输出的作为输入的并行加法器中，花费的时间是$2nty$，其中$n$是参加运算的数的位数。时间复杂度$O(n)$。</p>
<p>但是，时间复杂度是下降必然引起空间复杂度（电路中门的数量）的上升。据肉眼观察，之前的空间复杂度是$O(n)$，但新方法的空间复杂度是$O(n^2)$。如果所有位都用新的方法，那么电路的结构以及造价会飞快地上升。对于一个位数很长的数，直接使用这种并行进位法是不合适的。</p>
<h4 id="分组并行进位"><a href="#分组并行进位" class="headerlink" title="分组并行进位"></a>分组并行进位</h4><p>并行进位法在位数很大的时候就不合适了，但这种方法依然有利用的价值。4位数的并行进位电路是可以接受的。如果我们把一个很长的数每4位看成一组，分别放进4位的并行进位电路，那么电路的进速度还是得到了优化了的。准确来讲，应该是快了4倍。这种电路叫做4位先行进位电路（Carry Look Ahead，CLA）。其耗费时间是$\frac{n}{2}ty$。</p>
<p>可以发现，我们把每四位看成了一个组。这个组的概念，和原来每一位的概念是类似的。原来每一位的运算要输入$A_i,B_i,C_{i - 1}$，输出$C_i$；现在每一组输入$A_i \sim A_{i+3},B_i\sim B_{i+3},C_{i - 1}$，输出$C_{i+3}$。原来的位变成了现在的组。这实际上是一个递归的过程。</p>
<p>我们可以把4位当成一组，是不是也可以把几个组当成一个大组并行运算呢？</p>
<p>根据公式：</p>
<p>$C_4 = G_4 + P_4G_3 + P_4P_3G_2 + P_4P_3P_2G_1 + P_4P_3P_2P_1C_0$</p>
<p>和之前一样，把前面不含$C_0$的看成一个整体，含$C_0$的看成一个整体。可以得到：</p>
<p>$C_4 = G_1^<em>+P_1^</em>C_0$</p>
<p>因为我们每4位分成了一组，所以$C_8$也有类似的式子：</p>
<p>$C_8 = G_2^<em>+P_2^</em>C_4$</p>
<p>同样，如果把$C_4$代入，那么$C_8$也只含$C_0$这一个变量了。现在$C_4,C_8,C_{12}…$都可以并行计算出来了。为了产生$G^<em>P^</em>$，原来产生$C_4,C_8,C_{12}$的CLA电路要修改，把输出从$C_4…$改成$G^<em>P^</em>$。这种改过的电路叫做成组先行进位电路（Block Carry Look Ahead，BCLA）。</p>
<p>新的加法器原理和之前一样，但和之前不同的是，开始的进位输入只有$C_0$，而BCLA需要$C_4,C_8,C_{12}…$。在得到每一组的这些输入后，我们才能把每一组组内的结果算出来。</p>
<p>总结一下，新的电路分了三步：第一步，所有的$G^<em>,P^</em>$是从$G,P$中计算而来，需要额外花$2ty$有关计算所有的$G^<em>,P^</em>$；第二步，根据$G^<em>,P^</em>,C_0$，计算出$C_4,C_8,C_{12}…$，这种组内的运算用到的是开始的并行加法器，也要花费$2ty$时间；第三步，根据$C_4,C_8,C_{12}…$，计算每一组内部的进位，时间同样是$2ty$。总共花费了$6ty$的时间。特别地，由于$C_0$在一开始就已知，第一组组内的计算可以在第一个$2ty$里算出来。</p>
<p>这部分内容比较复杂，照着课本上电路的结构图能够更快地理解这些内容。</p>
<h2 id="定点加减计算"><a href="#定点加减计算" class="headerlink" title="定点加减计算"></a>定点加减计算</h2><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码十分死板，因为只有原码的绝对值才有意义。而且在进行加减的时候，还要考虑两个数前面的正负号，才能决定绝对值是加还是减，非常麻烦。</p>
<p>首先需要一个逻辑电路，通过两个数的符号位和当前的运算得到绝对值进行的是加还是减运算。</p>
<p>对于绝对值加，直接加。对于绝对值减，减数要变补再加。</p>
<p>如果最终加的结果的负数，还要再求一次补，把负数转化成它的绝对值。结果的符号位也要取反。</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>由于补码中负数的表示是在模$2^n$意义下的,因此直接带上符号位计算就行了。</p>
<h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><p>把减数取负再做加法即可。问题是怎么把一个数取负。</p>
<p>口诀教的是：连同符号位一起取反，末尾+1，就得到了一个数的相反数。</p>
<p>我觉得按求负数补码的方式，倒着想也没错。正数就和上面一样取反+1，负数-1再全部取反。</p>
<h4 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h4><p>符号扩展就是一个位短的数如何正确强制转换成一个位长的数。方法很简单：正数补0负数补1。</p>
<h3 id="补码溢出"><a href="#补码溢出" class="headerlink" title="补码溢出"></a>补码溢出</h3><p>计算机运算都是在模意义下的。运算结果绝对值比模数/2大，就会发生溢出现象，运算结果因为无法表示而变得不正确。</p>
<p>只有同号加法才会溢出，因为异号加法绝对值一定变小。</p>
<p>比较简单的判溢出方法是：在当前符号位左边扩展一位，就是整数补0负数补1。之后用拓展过的数进行计算。如果两个符号位是10，表示负数溢出；符号位是01表示正数溢出。</p>
<h3 id="补码运算的电路"><a href="#补码运算的电路" class="headerlink" title="补码运算的电路"></a>补码运算的电路</h3><p>这个章节划分得很没有条理。不过这一小节也不重要，课本写得不详细，老师也没讲几句。</p>
<h2 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h2><p>移位是乘除法的基础，所以在这一节先介绍一下。</p>
<h3 id="移位规则"><a href="#移位规则" class="headerlink" title="移位规则"></a>移位规则</h3><p>移位规则十分简单，用过C语言的移位运算的话很容易就能学会。</p>
<p>宏观上来看，不管符号位如何，左移要让数乘2，右移要让数除以2。</p>
<p>正数左右移补0，负数左移补0右移补1。</p>
<p>要用电路实现移位，要么用移位寄存器，要么用移位器进行计算后保存计算结果。移位操作就是一个多路选择器，等于是输入到输出的一个一对一映射。</p>
<h3 id="舍入操作"><a href="#舍入操作" class="headerlink" title="舍入操作"></a>舍入操作</h3><p>右移时，有些数位会多出来，需要舍弃。舍入方法有：</p>
<ol>
<li>恒舍：什么都不管，直接全舍去。</li>
<li>冯诺依曼舍入法：什么都不管，舍去，剩下的数最后一位置1.</li>
<li>下舍上入：被舍的最后一位（保留的最右边的一位的右边一位）是1则前面保留的部分+1.</li>
<li>查表舍入：把方法3放进一个表里，减少++成本。</li>
</ol>
<h2 id="定点乘法计算"><a href="#定点乘法计算" class="headerlink" title="定点乘法计算"></a>定点乘法计算</h2><p>方法中的“一位“、”两位“把乘除法计算步骤拆开后，每次做加法是逐位考虑还是每两位考虑。</p>
<h3 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h3><p>和加法一样，原码做乘法的时候需要把符号位和绝对值分开处理。</p>
<p>符号位很好处理，做一个异或就行了。</p>
<p>绝对值相乘的步骤和我们列竖式手算乘法是一模一样的。由于二进制里只有0和1，因此每一步中要么加上被乘数，要么不加。这种是否关系刚好和逻辑电路相符合。</p>
<p>但是，我们列竖式的时候，每次新算出来的部分积都会往左一位，电路不方便做这样的操作。因此，电路每次把旧的部分积右移，以代替新部分积左移。</p>
<p>只要看一眼课本上的例题就能快速理解这个过程</p>
<h3 id="补码一位乘法"><a href="#补码一位乘法" class="headerlink" title="补码一位乘法"></a>补码一位乘法</h3><p>补码中由于符号位参与运算，其计算过程更加复杂一点。</p>
<h4 id="校正法"><a href="#校正法" class="headerlink" title="校正法"></a>校正法</h4><p>第一想法是把被乘数的符号位分开，即先对被乘数后面的部分进行计算，如果被乘数符号位是1（是负数），就再加上一个乘数的相反数乘上被乘数符号位。这种方法加入一个特判，电路实现很不方便。</p>
<h4 id="Booth乘法"><a href="#Booth乘法" class="headerlink" title="Booth乘法"></a>Booth乘法</h4><p>有人发现补码乘法有一个特殊的性质：</p>
<script type="math/tex; mode=display">
\begin{aligned}

\ [X\times Y]_{补}&=[X]_{补}\times(0.Y_1Y_2...Y_n)+[-X]_{补}\times Y_s \\
\ &= [X]_{补}\times(Y_12^{-1}+Y_22^{-2}...+Y_n2^{-n})+[-X]_{补}\times Y_s \\
\ &= [X]_{补}\times(-Y_s+(Y_1-Y_12^{-1})+(Y_22^{-1}-Y_22^{-2})...+(Y_n^{-n+1} -Y_n2^{-n}))
\\
\ &= [X]_{补}\times((Y_1 - Y_s)+(Y_2 - Y_1)2^{-1}+...+(0 - Y_n)2^{-n}) \\
\ &= [X]_{补}\times((Y_1 - Y_s)+(Y_2 - Y_1)2^{-1}+...+(Y_{n+1} - Y_n)2^{-n}) \\

\end{aligned}</script><p>看完前几行后，就能发现这个性质了：补码乘法可以看成被乘数补码乘上乘数的相邻位比较结果码。注意最后一行，$Y_{n+1}$本来没有这个数，但在计算的时候为了统一，我们假设有这个数，并把它初始化为0。</p>
<p>有了这个公式，就可以直接进行补码乘法了。和之前一样，被乘数不断右移，但这次要看乘数最后一位和附加位的比较结果（附加位就是前一位，初始化为0）。如果当前位和附加位一样则不加；如果附加位是0这一位是1则减掉被乘数；如果附加位是1这一位是0则加上被乘数。</p>
<h3 id="补码两位乘法"><a href="#补码两位乘法" class="headerlink" title="补码两位乘法"></a>补码两位乘法</h3><p>两位乘法就是每次考虑乘数的两位，加快乘法速度。</p>
<p>乘法还是用Booth法，但是这次比较位有些复杂。但只要记住公式会化简成$(Y_{i+1}+Y_i-2Y_{i-1})$就行了。记住这个公式就能记住每一位权是多少</p>
<h2 id="定点除法计算"><a href="#定点除法计算" class="headerlink" title="定点除法计算"></a>定点除法计算</h2><p>和乘法一样，除法的计算思路也由竖式中得来。同样，我们先从普通的原码除法，推广到补码除法。</p>
<h3 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h3><p>同样，考虑原码时我们只关心绝对值部分。</p>
<p>根据正常的列竖式除法，如果每次被除数比除数大，就商1，被除数减去除数，除数右移。在电路中，除数右移不方便，改成部分余数左移。这种比较法要用到比较电路，很麻烦。</p>
<p>一种想法是，每次不管被除数和除数，先减了再说。如果减成了一个非负数，就正常商1；否则，若减成了一个负数，就说明这次不够减，商0。如果这次把除数又加回来的话，下一步操作我们又无脑减一次除数。这次加回除数和下次再减一次除数可以合并成一个操作，就是忽略本次的负数，下次加一次除数。也就是说，若$r_i = 2r_{i - 1} - Y$小于0，则本次操作先不恢复这个数，而是令$r_{i+1}=2r_i+Y$，因为$2r_i+Y=2(r_i+Y)-Y$,其中$r_i+Y$是回复了余数的结果。</p>
<h3 id="补码除法"><a href="#补码除法" class="headerlink" title="补码除法"></a>补码除法</h3><p>补码中，要考虑到负数，算法复杂了一些。</p>
<p>仔细一想，算法中部分余数（包括被除数）一直在变，只有除数的值没有变化。所有的符号都应该是相对于除数而言的。</p>
<p>也就是说，原码除法可以看成补码除法的一种特殊情况，这是除数一直是正数。而当除数变成负数后，如果被除数是正数，说明”不够减“，商0；否则”够减“，商1。也就是说，我们要修正之前的加减交替法，把判断一个数是否不够减的一句擀成是否和除数异号。</p>
<h2 id="规格化浮点计算"><a href="#规格化浮点计算" class="headerlink" title="规格化浮点计算"></a>规格化浮点计算</h2><h3 id="浮点加减"><a href="#浮点加减" class="headerlink" title="浮点加减"></a>浮点加减</h3><p>设：</p>
<script type="math/tex; mode=display">
A = M_A \times 2^{E_A} \\
B = M_B \times 2^{E_B}</script><p>浮点数加减前要对齐阶，阶小往阶大的移动。先计算$\Delta E = E_A - E_B$。$\Delta = 0$若等于0则不用管；若大于</p>
<p>0则B右移；否则A右移移。之后尾数加减。</p>
<p>由于尾数要满足规格化数（科学计数法）的要求，需要对尾数加减结果进行规格化。</p>
<p>假设尾数用双符号位表示。对于尾数计算结果的下列情况：</p>
<ol>
<li>00.1XXX | 11.0XXX 符号位和首位不同，满足规格化的要求</li>
<li>00.0XXX | 11.1XXX 符号位和首位相同，绝对值小了，要把尾数放大（左移），阶码每次—。</li>
<li>01.XXXX | 10.XXXX 双符号位仅在此处发挥作用。双符号位不同说明发生定点溢出，浮点超1。需要把尾数缩小，阶码++。</li>
</ol>
<h3 id="浮点相乘"><a href="#浮点相乘" class="headerlink" title="浮点相乘"></a>浮点相乘</h3><p>阶码相加（有移码则要减掉），尾数相乘。</p>
<p>尾数大小一定落在$[\frac{1}{4}, 1)$,仅在尾数小于二分之一的时候需要进行左移，阶码—。</p>
<h3 id="浮点相除"><a href="#浮点相除" class="headerlink" title="浮点相除"></a>浮点相除</h3><p>为了使尾数规格化，要保证被除数的尾数的绝对值比除数小，即$|M_A| &lt; |M_B|$。由于二者本身就是规格化数，这个操作至多操作一次。</p>
<p>之后阶码相减，尾数相除。</p>
<h2 id="十进制加减"><a href="#十进制加减" class="headerlink" title="十进制加减"></a>十进制加减</h2><p>没什么需要学的内容。十进制每一位都用4位二进制表示，每4位单独运算即可。</p>
<h2 id="运算器实现"><a href="#运算器实现" class="headerlink" title="运算器实现"></a>运算器实现</h2><p>这一节内容又很偏硬件实现，应该不会去考。</p>
<p>反正我就记住了两种芯片，74182对应CLA电路，74181对应BCLA电路。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>本节有很多运算，动手把这些运算算一遍才能保证自己完全理解了这些概念。</p>
<p>我在做题的时候发现了一些坑点：</p>
<ul>
<li>原码乘法最后还要再移位一次，补码乘法不需要。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2020/01/06/Principles-of-Computer-Composition-cources-review-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/06/Principles-of-Computer-Composition-cources-review-3/" class="post-title-link" itemprop="url">计算机组成原理复习：第三章 指令系统</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-01-06 12:15:12" itemprop="dateCreated datePublished" datetime="2020-01-06T12:15:12+08:00">2020-01-06</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/Principles-of-Composition/" itemprop="url" rel="index"><span itemprop="name">Principles of Composition</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章的内容主要是上课的时候写的，复习的时候我又修改了一些地方。</p>
<h1 id="计算机组成原理复习：第三章-指令系统"><a href="#计算机组成原理复习：第三章-指令系统" class="headerlink" title="计算机组成原理复习：第三章 指令系统"></a>计算机组成原理复习：第三章 指令系统</h1><p>指令对应机器语言，是计算机中最基本的命令。</p>
<p>本章先整体介绍了指令的结构，包括了操作码、地址码两个部分，并简要介绍两者所占长度的问题。之后，本章对地址码和操作分别进行了进一步介绍。先是介绍了地址码的具体知识，因为地址码可能不表示一个具体的地址，而是通过一些间接的方式来获取地址。特别地，有一部分存储区构成了栈结构，有一些操作专门是针对堆栈的。然后是一些具体的指令操作。最后，本着从普适性到具体性的思想，本章介绍了指令集中应该具有的操作，以及一些具体的指令集的发展过程。</p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p>指令就是一段二进制代码。指令可以分成两部分，前一部分是操作码，后一部分是地址码。我觉得可以把操作码看成函数名，地址码看成函数参数。准确来讲，地址码是表示数据的代码，用地址码获取数据的方式再寻址技术部分会提到。</p>
<h3 id="地址码结构"><a href="#地址码结构" class="headerlink" title="地址码结构"></a>地址码结构</h3><p>函数的参数可以有多有少。我们默认讨论双操作数系统。在指令这个“函数”中，最多支持4个参数。可惜的是，这个函数只支持默认参数来实现重载。也就是说，所有的指令实际上都会需要4个参数，但有些参数可能存在其它位置（可以看成一个全局变量），或者某些操作不需要所有4个参数。所以指令实际传入的操作数数量可能是0~4个。</p>
<p>指令传入的4个参数是：第一操作数地址，第二操作数地址，运算结果地址，下一条指令的地址。和C++的默认参数一样，每少输入一个参数，就代表最后的那个参数被设为了默认值。</p>
<p>3参数指令默认将下一条指令的地址设为当前指令地址+1。2参数指令把运算结果到第一操作数的地址。1参数指令把另一操作数存在某一个寄存器里。0参数指令一般是堆栈操作，把栈顶元素当成参数来进行操作。</p>
<h3 id="操作码结构"><a href="#操作码结构" class="headerlink" title="操作码结构"></a>操作码结构</h3><p>操作码的长度可以固定，也可以不固定。后者可以节约空间，因为多地址的操作中地址码的长度较长，可以分配比较短的操作码。</p>
<p>显然，和哈夫曼编码一样，不能有一个操作码是另一个操作码的前缀。</p>
<h2 id="寻址技术"><a href="#寻址技术" class="headerlink" title="寻址技术"></a>寻址技术</h2><p>寻址指获取操作数或指令的地址。实际上，这一节不仅讲了如何寻址，还先讲了如何编址。</p>
<h3 id="编址"><a href="#编址" class="headerlink" title="编址"></a>编址</h3><p>编址就是给寄存器、主存或IO设备中的存储单元编号，这样通过一个编号就能唯一地找到存在某处的一个数了。</p>
<p>编址最重要的是编址的最小单位。如果编址最小单位是字，那么在一个字长16位的系统里，你只能通过地址区分每16位数，而不能唯一确定数据某个字中的哪个地方；如果编址最小单位是字节，那么你就可以区分每8位的数字；如果编址最小单位是位，那么你可以精确地访问每一位了。</p>
<p>显然，编址最小单位是位的话，地址就会变得非常长了。还按字节编址比较好一些。在C语言中，我们可以得到每一个char的地址，这大概是字节编址的一个体现。</p>
<p>编址长度和主存的字长不是一个概念。</p>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>主要讲怎么寻找数据的地址。</p>
<p>最简单的是把数据直接放在指令里，这样不需要取通过地址来访问数据了。也就是往函数直接传了个值。但这样传进去的值的位数可能不够多。</p>
<p>还可以传数据的地址，也就是传指针。有时为了方便，还可以寻两次地址，也就是传指针的指针。数据可以在寄存器里找，也可以在主存里找，共$2\times 2 =4$种方法。这里还要多提一句，寄存器间接寻址指的是第一次在寄存器里找地址，第二次还是在主存里找。</p>
<p>此外，为了方便地获取一段连续的数据，还可以用基础地址加偏移量的方式获取数据。用C语言来写的话，就是</p>
<p><code>*(p + i)</code>。<code>p</code>表示基础地址，<code>i</code>是偏移量。如果<code>i</code>在寄存器中，就叫做变址寻址；如果<code>p</code>在寄存器中，就叫做基址寻址。理论上这两种寻址方式表示的意思都是一样的，硬件实现方式也可能是相同的，但二者使用上有一些细微的差别。由于用户希望改变对于某个基址的偏移量<code>i</code>，因此变址寻址是一个面向用户的操作。</p>
<p>此外，在基址寻址的基础上，基址<code>p</code>可以来自程序计数器。这种寻址方式叫相对寻址。</p>
<h2 id="指令类型"><a href="#指令类型" class="headerlink" title="指令类型"></a>指令类型</h2><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>数据是在寄存器和主存之间传输的，理论上存在4种不同起点和重点的传输指令。把寄存器看成0，主存看成1，有序对<0,0>,<0,1>,<1,0>,<1,1>就可以表示4种数据传输的指令了。</1,1></1,0></0,1></0,0></p>
<p>此外，还有对堆栈的PUSH和POP指令。但是，这两种指令本质上也是对于主存的操作，并不能称为最基本的操作。</p>
<p>除了单向传输，还可以交换两个位置的数据。</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>包含C语言中的一些基本运算。比如加减乘除模、按位逻辑运算、移位运算。但书中没有具体讲这种指令的结构（比如有几个操作数）。</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="转移"><a href="#转移" class="headerlink" title="　转移"></a>　转移</h4><p>转移有两种：有条件转移和无条件转移。有条件转移用于实现条件语句，而无条件转移让程序结构更加灵活，不必受到顺序存储的束缚。</p>
<p>转移都要定义转移到的地址这一参数。对于有条件转移，还要把比较条件作为参数。</p>
<h4 id="子程序调用"><a href="#子程序调用" class="headerlink" title="子程序调用"></a>子程序调用</h4><p>一个程序通过一些指令，可以调用另一个程序。只是根据调用关系，把被调用的程序叫做子程序。</p>
<p>程序本身就是被调用的，这种调用其他程序的关系中体现了递归的思想。</p>
<p>子程序调用也可以让程序不按顺序执行，而是跑到另一个地方去执行。在这一点上，它和转移十分类似。为了搞清这两个概念，要知道这两个概念间的区别。</p>
<h5 id="子程序调用与转移的区别"><a href="#子程序调用与转移的区别" class="headerlink" title="子程序调用与转移的区别"></a>子程序调用与转移的区别</h5><ol>
<li>子程序有“返回”这一操作。在调用了子程序后，一定要进行返回，返回到调用子程序的下一条指令。</li>
<li>机器中应该有“程序”这个概念，也就是说不同程序之间是有明确的界限的。转移只能在当前程序中转移，而调用子程序会跳转到子程序的开头。</li>
</ol>
<p>既然调用子程序的时候要返回，那么机器必须存储返回的地址。事实上，每调用一次子程序就会产生一条返回地址信息。有多种存储返回地址的方法。</p>
<h5 id="返回地址的存储"><a href="#返回地址的存储" class="headerlink" title="返回地址的存储"></a>返回地址的存储</h5><ol>
<li>存到子程序的开头。我觉得这种方法很蠢，递归调用完全不可行了。但如果没有递归的话，这样设计节约了存储空间。</li>
<li>先存到寄存器中，再让子程序把寄存器的内容存到内存中。这样不错。</li>
<li>存到堆栈中。这种方法和2的本质是一样的。函数调用本身就类似栈的行为，用栈模拟的话更加自然，更加易于操作。但是，我觉得这种分类还是不够清楚。方法2里，你把东西存在内存里，在内存里也可以构成一个堆栈。方法3理论上是方法2的一个改进，而不是完全没有交集的两个方法。</li>
</ol>
<h4 id="返回指令"><a href="#返回指令" class="headerlink" title="返回指令"></a>返回指令</h4><p>返回指令明明是和子程序调用配套出现的，不懂书上为什么要单独列出来。</p>
<h3 id="输入输出指令"><a href="#输入输出指令" class="headerlink" title="输入输出指令"></a>输入输出指令</h3><p>输入输出往往要用到除主存之外的存储区域。因此，IO指令可以分成两类。一种是IO地址单独编址，从0开始命名；另一种是把IO的地址接到主存后面。前者较独立编址，后者较统一编址。</p>
<p>我感觉这一小节涉及的内容还是比较少的，考试应该不会考。</p>
<h2 id="指令集的发展"><a href="#指令集的发展" class="headerlink" title="指令集的发展"></a>指令集的发展</h2><p>讲了一些很虚的东西，没什么价值。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2020/01/05/Principles-of-Computer-Composition-cources-review-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/05/Principles-of-Computer-Composition-cources-review-2/" class="post-title-link" itemprop="url">计算机组成原理复习：第二章 数据表示</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-01-05 21:17:33" itemprop="dateCreated datePublished" datetime="2020-01-05T21:17:33+08:00">2020-01-05</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/Principles-of-Composition/" itemprop="url" rel="index"><span itemprop="name">Principles of Composition</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机组成原理复习：第二章-数据表示"><a href="#计算机组成原理复习：第二章-数据表示" class="headerlink" title="计算机组成原理复习：第二章 数据表示"></a>计算机组成原理复习：第二章 数据表示</h1><p>实际上，这章讲的是数据是怎么编码的。大部分时候，都是在讲二进制编码。本章编码不特别说明都是在指二进制下的编码。</p>
<h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>数值是运算中最常见的成分。</p>
<p>非得分类的话，数字可以分成整数和小数。但小数的表示方法中也是用到了整数的。因此本章先介绍整数怎么表示。</p>
<h3 id="原码-补码-反码"><a href="#原码-补码-反码" class="headerlink" title="原码 补码 反码"></a>原码 补码 反码</h3><p>无符号的数直接用二进制表示。</p>
<p>有符号的数因为有正负，所以编码的第一个任务就是把正数和负数区分开来。如果把最高位当成符号位，0表示正1表示负，后面当成无符号数表示，那么这种表述法就是原码表示。反码和补码都是对原码的负数表示进行更改。反码是把负数的每一位取反，补码是把原码的每一位取反加一。补码和反码的原理都是取模，把一个模意义下很大的正数视为一个负数。</p>
<p>其中，补码的特点是0只有一种表示方法，从而负数可以多表示一个数；原码和补码都有一个+0一个-0.</p>
<h3 id="定点表示"><a href="#定点表示" class="headerlink" title="定点表示"></a>定点表示</h3><p>定点可以表示小数和正数。</p>
<p>定点小数的第一位是符号位，小数点固定在第一位后面。也就是说，所有数是零点几。定点整数第一位也是符号位，小数点固定在最后一个数后面，和之前讲的整数表示完全相同。</p>
<p>定点小数根本不实用。但是它在后面会被利用到。</p>
<h3 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h3><p>计算机中，小数都用浮点表示法，即小数点的位置可以移动。在这种表示法下，一个数的数位被拆成了两部分：一部分是指数，称为阶码；一部分是底数，称为尾数。</p>
<h1 id="我写完了这篇文章，写完了忘了保存，直接上传到博客。我退出文章的时候提示是否要保存，由于文章上传到博客草稿文件消失，一定会提示是否保存，我就选择了丢弃。结果我辛辛苦苦写的内容全部消失了。复习时间太少，这篇文章今天晚上就不补了。以后有缘再补完这篇文章或者删掉这篇文章。气死我了！"><a href="#我写完了这篇文章，写完了忘了保存，直接上传到博客。我退出文章的时候提示是否要保存，由于文章上传到博客草稿文件消失，一定会提示是否保存，我就选择了丢弃。结果我辛辛苦苦写的内容全部消失了。复习时间太少，这篇文章今天晚上就不补了。以后有缘再补完这篇文章或者删掉这篇文章。气死我了！" class="headerlink" title="我写完了这篇文章，写完了忘了保存，直接上传到博客。我退出文章的时候提示是否要保存，由于文章上传到博客草稿文件消失，一定会提示是否保存，我就选择了丢弃。结果我辛辛苦苦写的内容全部消失了。复习时间太少，这篇文章今天晚上就不补了。以后有缘再补完这篇文章或者删掉这篇文章。气死我了！"></a>我写完了这篇文章，写完了忘了保存，直接上传到博客。我退出文章的时候提示是否要保存，由于文章上传到博客草稿文件消失，一定会提示是否保存，我就选择了丢弃。结果我辛辛苦苦写的内容全部消失了。复习时间太少，这篇文章今天晚上就不补了。以后有缘再补完这篇文章或者删掉这篇文章。气死我了！</h1>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2020/01/05/Principles-of-Computer-Composition-cources-review-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/05/Principles-of-Computer-Composition-cources-review-1/" class="post-title-link" itemprop="url">计算机组成原理复习：第一章 概论</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-01-05 19:17:22" itemprop="dateCreated datePublished" datetime="2020-01-05T19:17:22+08:00">2020-01-05</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/Principles-of-Composition/" itemprop="url" rel="index"><span itemprop="name">Principles of Composition</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>期末考试又到了，又有一些课要复习。</p>
<p>我在上课的时候曾经做过一些“学习记录”，其形式是以自己的话来重述课本的内容，并且加上很强的主观评论。我复习的时候也采用这种形式。为了节约时间，有些吐槽会少一些，但这并不代表这门课没有喷点。</p>
<h1 id="计算机组成原理复习：第一章-概论"><a href="#计算机组成原理复习：第一章-概论" class="headerlink" title="计算机组成原理复习：第一章 概论"></a>计算机组成原理复习：第一章 概论</h1><p>​    这一章做为全书的总结，都是一些很泛的东西，没有太多有价值的知识。准确来说，都是一些具体知识而没有任何理论知识在内。我照着考试复习PPT把重点列一下。</p>
<h2 id="计算机的组成部分"><a href="#计算机的组成部分" class="headerlink" title="计算机的组成部分"></a>计算机的组成部分</h2><p>五个部分：</p>
<ul>
<li><p>存储器</p>
</li>
<li><p>运算器</p>
</li>
<li><p>控制器</p>
</li>
<li><p>输入设备</p>
</li>
<li><p>输出设备</p>
</li>
</ul>
<p>这些东西大一就记过了。</p>
<h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>特点：共享、分时</p>
<p>类别：地址、数据、控制总线</p>
<h2 id="计算机系统组成部分"><a href="#计算机系统组成部分" class="headerlink" title="计算机系统组成部分"></a>计算机系统组成部分</h2><p>软件+硬件</p>
<h2 id="计算机性能指标（部分）"><a href="#计算机性能指标（部分）" class="headerlink" title="计算机性能指标（部分）"></a>计算机性能指标（部分）</h2><h3 id="时钟频率和时钟周期"><a href="#时钟频率和时钟周期" class="headerlink" title="时钟频率和时钟周期"></a>时钟频率和时钟周期</h3><p>可以类比游戏里的FPS和每帧所需时间。</p>
<h3 id="吞吐量、响应时间"><a href="#吞吐量、响应时间" class="headerlink" title="吞吐量、响应时间"></a>吞吐量、响应时间</h3><p>这个在操作系统里提过。吞吐量指单位时间完成的请求的数量，似乎没有一个严格的单位。响应时间指一个任务等待和最终执行所耗时间之和。</p>
<h3 id="CPI"><a href="#CPI" class="headerlink" title="CPI"></a>CPI</h3><p>Cycles per Instructions，每条指令所花时间周期数</p>
<p>IPC就是倒数</p>
<h3 id="MIPS-MFLOPS"><a href="#MIPS-MFLOPS" class="headerlink" title="MIPS MFLOPS"></a>MIPS MFLOPS</h3><p>MIPS(Million Instructions per Second)是每秒执行多少百万条指令。等于主频乘IPC</p>
<p>MFLOPS不是指指令而是浮点运算。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2019/12/30/Digital-Image-Processing-homework2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/30/Digital-Image-Processing-homework2/" class="post-title-link" itemprop="url">数字图像处理小作业2：图像扭曲与修复（高斯模糊、高斯噪声、维纳滤波）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-30 11:33:00" itemprop="dateCreated datePublished" datetime="2019-12-30T11:33:00+08:00">2019-12-30</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/Digital-Image-Processing/" itemprop="url" rel="index"><span itemprop="name">Digital Image Processing</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数字图像处理小作业2"><a href="#数字图像处理小作业2" class="headerlink" title="数字图像处理小作业2"></a>数字图像处理小作业2</h1><h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><p><a href="https://github.com/SingleZombie/WienerFilteringCpp" target="_blank" rel="noopener">https://github.com/SingleZombie/WienerFilteringCpp</a></p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>老师给的需求如下：</p>
<ul>
<li>读入一幅灰度图像</li>
<li>生成模糊图像：高斯模糊滤波+噪声</li>
<li>利用维纳滤波去模糊</li>
</ul>
<p>总结来说，本次作业处理的图像对象是灰度图。灰度图要经过扭曲和修复两个过程。扭曲是高斯模糊和噪声（我选择了高斯噪声），修复用的是维纳滤波的方法。</p>
<p>相比上次的作业，本次需求清晰了不少。</p>
<h2 id="技术学习"><a href="#技术学习" class="headerlink" title="技术学习"></a>技术学习</h2><h3 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h3><p>模糊一个图像，可以通过卷积核来实现。具体来说，就是把一个像素的值加上它旁边几个像素的值。这样从直观上来看，像素之间的差异被减小了，图片就变模糊了。</p>
<p>问题是，一个像素值该如何加上旁边几个像素的值？每个像素相加的权重是什么？有人把二维高斯分布函数当成概率密度函数，权重就是概率密度函数的值。这样的利用高斯函数来计算卷积核权重的模糊方法就是高斯模糊。</p>
<h3 id="高斯噪声"><a href="#高斯噪声" class="headerlink" title="高斯噪声"></a>高斯噪声</h3><p>噪声就是把某个位置的像素值改变多少看成一个随机变量。如果随机变量符合高斯分布，那么这个噪声就是高斯噪声。随机变量和位置无关，只和随机变量自己的性质（均值、方差）有关。</p>
<h3 id="维纳滤波"><a href="#维纳滤波" class="headerlink" title="维纳滤波"></a>维纳滤波</h3><p>图像修复就是假设一个扭曲模型（输入为原图像的一个函数），之后设法求出这个模型中的参数，再利用这些参数复原图像。</p>
<p>维纳滤波就是假设原图像经过了一个卷积和一个噪声添加。该方法要的思想是让复原出的图像和原图像的”差异“尽可能小，这个”差异“被定义为均方误差。由于我没有学过信号处理这门课，而本课程又更关注算法的使用而非原理，这里不加证明地给出最终的式子：</p>
<script type="math/tex; mode=display">
\hat{F}(u,v) = [\frac{1}{H(u,v)} \cdot \frac{|H(u, v)|^2}{|H(u, v)|^2 + k}]G(u,v)</script><p>其中$\hat{F}(u,v)$是复原出来的图像的频域值，$H(u,v)$是退化函数在频域下的表示，$G(u,v)$是被扭曲过的图像。而$k$是一个可调的参数。</p>
<p>本次任务的难点应该就是调试$k$这个参数。</p>
<p>有一篇<a href="https://blog.csdn.net/baimafujinji/article/details/73882265" target="_blank" rel="noopener">博客</a>对维纳滤波的原理以及matlab下的实现做了讲解。</p>
<h3 id="OpenCV用法"><a href="#OpenCV用法" class="headerlink" title="OpenCV用法"></a>OpenCV用法</h3><p>写着写着发现又碰到了很多不会用的函数。</p>
<h4 id="cv-normalize"><a href="#cv-normalize" class="headerlink" title="cv::normalize"></a><code>cv::normalize</code></h4><p><code>cv::normalize(src, dest, upper_bound = 1, lower_bound = 0, norm_type = cv::NORM_L2);</code></p>
<p>normalize用于归一化，避免一个向量的模变大。在图像中，卷积核做归一化可以保证图像的亮度不变。</p>
<p>我只会用这个函数的前5个参数，有几个参数的名字是我取的。</p>
<p><code>src</code>：原图像</p>
<p><code>dest</code>：输出图像</p>
<p><code>upper_bound</code>：归一化后的上界</p>
<p><code>lower_bound</code>：归一化后的下界    </p>
<p><code>norm_type</code>：归一化的范式</p>
<p>归一化的基本操作就是要让模为1，因此输出的下界是0，上界是1。归一化的操作是把向量的每个分量都除以向量的模。</p>
<p>范式就是模是如何计算的。第一范式把模计算成所有分量之和，第二范式把模计算成所有分量平方和开方…………无穷范式把模计算成最大分量。</p>
<h4 id="cv-filter2D"><a href="#cv-filter2D" class="headerlink" title="cv::filter2D"></a><code>cv::filter2D</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::filter2D(srcMat, destMat, ddepth, kernel, anchor = (-1, -1))</span><br></pre></td></tr></table></figure>
<p>这个函数用于做图像的卷积，省去了手写循环的无聊过程。</p>
<p>同样，我只列出了我会的参数，参数名字是随意写的。</p>
<p><code>srcMat</code>：原图像</p>
<p><code>destMat</code>：输出图像</p>
<p><code>ddepth</code>：输出图像深度，-1为和原图像相同</p>
<p><code>kernel</code>：卷积核</p>
<p><code>anchor</code>：锚点，也就是被卷积的点在卷积核的哪个位置。(-1, -1)是卷积核正中心</p>
<h4 id="cv-dft"><a href="#cv-dft" class="headerlink" title="cv::dft"></a><code>cv::dft</code></h4><p><code>cv::dft(srcMat, destMat, flag)</code></p>
<p>这个函数就是做离散傅里叶变换，内部实现方法肯定是用FFT做的。</p>
<p><code>srcMat</code>：原图像</p>
<p><code>destMat</code>：输出图像</p>
<p><code>flag</code>：操作的一些参数。我知道的参数有：</p>
<p>​    <code>cv::DFT_CCOMPLEX_OUTPUT</code>: 输出结果以复数形式存储，通道数增加。我输入单通道的图像出来是双通道的。</p>
<p>​    <code>cv::DFT_REAL_OUTPUT</code>：仅保留结果复数的实数部分，通道数不变。</p>
<p>​    <code>cv::DFT_SCALE</code>：运算结束后除以一个数，用于IFFT中</p>
<p>​    <code>cv::DFT_INVERSE</code>：做的是逆变换。</p>
<p>在我的程序里，FFT的写法是<code>cv::dft(src, dest, cv::DFT_COMPLEX_OUTPUT);</code>，IFFT的写法是<code>cv::dft(src, dest, cv::DFT_SCALE | cv::DFT_INVERSE | cv::DFT_REAL_OUTPUT);</code></p>
<h3 id="C-标准库用法"><a href="#C-标准库用法" class="headerlink" title="C++标准库用法"></a>C++标准库用法</h3><p>本次程序中我竟然碰到了完全没见过的c++标准库函数。</p>
<h4 id="std-normal-distribution"><a href="#std-normal-distribution" class="headerlink" title="std::normal_distribution"></a><code>std::normal_distribution</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::random_device divice;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">default_random_engine <span class="title">rng</span><span class="params">(divice())</span></span>;</span><br><span class="line"><span class="built_in">std</span>::normal_distribution&lt;&gt; normDis(mu, sigma);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> randomNumber = normDis(rng);</span><br></pre></td></tr></table></figure>
<p>正态分布函数在c++的随机数库中。使用c++的随机数库有一些麻烦。语句前两行貌似是一个分布函数的初始化步骤，我不求甚解地直接使用了。语句第三行用平均值和方差初始化一个正态分布。初始化了之后每次就能获取一个符合正态分布的值了。</p>
<h3 id="用OpenCV完成的组合操作"><a href="#用OpenCV完成的组合操作" class="headerlink" title="用OpenCV完成的组合操作"></a>用OpenCV完成的组合操作</h3><p>本节讲的是完成某一功能的，使用到OpenCV的自定义函数。</p>
<p>我在完成这个作业的时候，参考了很多别人的博客。但是有些人用的是matlab实现的，里面出现了C++OpenCV里没有的函数。我只好去搜了一些这些函数的原理，参考了别人的C++实现并自己实现了一下。</p>
<h4 id="circShift"><a href="#circShift" class="headerlink" title="circShift"></a><code>circShift</code></h4><p><code>circShift(mat, x, y)</code></p>
<p>该函数的作用是，把一个矩阵<code>mat</code>向x轴正方向移动x个单位，向y轴正方向移动y个单位。移动中溢出的数字会填补到空出来的地方，也就是整个矩阵是循环移动的。</p>
<p>该函数实现起来很简单，先把x,y变成模意义下的值，再用临时矩阵做比较繁琐的<code>copyTo</code>就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="function">Mat <span class="title">circShift</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; mat, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mWidth = mat.cols;</span><br><span class="line">	<span class="keyword">int</span> mHeight = mat.rows;</span><br><span class="line">	x = (x % mWidth + mWidth) % mWidth;</span><br><span class="line">	y = (y % mHeight + mHeight) % mHeight;</span><br><span class="line"></span><br><span class="line">	cv::<span class="function">Mat <span class="title">res</span><span class="params">(mat.size(), mat.type())</span></span>;</span><br><span class="line">	cv::<span class="function">Mat <span class="title">m1</span><span class="params">(mat, cv::Rect(<span class="number">0</span>, <span class="number">0</span>, mWidth - x, mHeight))</span></span>;</span><br><span class="line">	cv::<span class="function">Mat <span class="title">m2</span><span class="params">(mat, cv::Rect(mWidth - x, <span class="number">0</span>, x, mHeight))</span></span>;</span><br><span class="line">	m1.copyTo(res(cv::Rect(x, <span class="number">0</span>, mWidth - x, mHeight)));</span><br><span class="line">	m2.copyTo(res(cv::Rect(<span class="number">0</span>, <span class="number">0</span>, x, mHeight)));</span><br><span class="line">	</span><br><span class="line">	cv::<span class="function">Mat <span class="title">res2</span><span class="params">(mat.size(), mat.type())</span></span>;</span><br><span class="line">	m1 = cv::Mat(res, cv::Rect(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight - y));</span><br><span class="line">	m2 = cv::Mat(res, cv::Rect(<span class="number">0</span>, mHeight - y, mWidth, y));</span><br><span class="line">	m1.copyTo(res2(cv::Rect(<span class="number">0</span>, y, mWidth, mHeight - y)));</span><br><span class="line">	m2.copyTo(res2(cv::Rect(<span class="number">0</span>, <span class="number">0</span>, mWidth, y)));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我对OpenCV的用法不算很熟，没有写性能更好的方法，我感觉我的写法<code>copyTo</code>用得有点多了。我写的时候比较匆忙，只顾着实现，没有考虑到性能的问题。</p>
<h4 id="psf2otf"><a href="#psf2otf" class="headerlink" title="psf2otf"></a><code>psf2otf</code></h4><p><code>psf2otf(mat, outSize = Size(-1, -1))</code></p>
<p>该函数的作用是，把一个二维点扩散函数转换成指定大小频域形式。</p>
<p>点扩散函数也许在数学上有其他定义，但根据我对该函数效果的理解，这里的点扩散函数指的就是一个用矩阵表示的二维函数，矩阵某位置的值表示二维函数在此处的函数值，该矩阵中心点是原点$(0, 0)$。</p>
<p>该函数的直接作用非常不好理解，但知道该函数的应用后就容易理解了。一个图像用一个卷积核卷积在时域上的计算可能比较慢，但是把图像和卷积核转换到到频域后，只要相乘，再转换回时域就可以得到卷积的结果了。由于卷积核的原点在中心点而不在左上角，且其大小可能比图像小，因此在卷积操作前需要把卷积核调整位置，并且扩大到和原图像一样的大小。经过处理后的卷积核的频域表示就能和原图像的频域表示进行正确的计算了。</p>
<p>该函数作用的宏观解释在明白函数的应用后，就比较容易理解了。但要理解其具体实现方法，需要了解FFT本身原理。我是通过理解一维FFT的原理后推广到二维的。</p>
<p>这里不加解释地直接给出该函数的具体操作了。该函数先把卷积核扩展至指定大小，再把卷积核的中心移动到左上角（准确来说是原点，计算机里左上角是原点）。注意这一步移动是循环移动，卷积核的部分内容被循环移动到了 右上角、左下角，右下角。扩展和移动结束后，再做FFT就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="function">Mat <span class="title">psf2otf</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; mat, cv::Size outSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (outSize.height == <span class="number">-1</span> || outSize.width == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		outSize = mat.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cv::Mat otf;</span><br><span class="line">	cv::Size paddleSize = outSize - mat.size();</span><br><span class="line">	cv::copyMakeBorder(mat, otf,</span><br><span class="line">		paddleSize.height - paddleSize.height / <span class="number">2</span>, paddleSize.height / <span class="number">2</span>,</span><br><span class="line">		paddleSize.width - paddleSize.width / <span class="number">2</span>, paddleSize.width / <span class="number">2</span>,</span><br><span class="line">		cv::BORDER_CONSTANT,</span><br><span class="line">		cv::Scalar::all(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	otf = circShift(otf, -otf.size().width / <span class="number">2</span>, -otf.size().height / <span class="number">2</span>);</span><br><span class="line">	otf = grayImageFFT(otf);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> otf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在写这个函数的时候参考了<a href="https://www.cnblogs.com/phoenixdsg/p/9058044.html" target="_blank" rel="noopener">这篇博客</a>。这篇博客的实现 在卷积结束以后，还判断了虚数部分是否比较小，可以忽略。但我没有多加这一步判断。</p>
<h4 id="图像与卷积核在频域的计算"><a href="#图像与卷积核在频域的计算" class="headerlink" title="图像与卷积核在频域的计算"></a>图像与卷积核在频域的计算</h4><p>这部分没什么新的内容，就是把代码组合了一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get frequent field of origin image</span></span><br><span class="line">cv::Mat fOrigin = grayImageFFT(origin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get frequent field of kernel and rearrange it</span></span><br><span class="line">cv::Mat h = getKernal(..........);</span><br><span class="line">cv::Mat funcH = psf2otf(h, mat.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute complex number multiply</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fOrigin.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; fOrigin.cols; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; g(fOrigin.at&lt;cv::Vec2f&gt;(i, j)[<span class="number">0</span>], fOrigin.at&lt;cv::Vec2f&gt;(i, j)[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; h(funcH.at&lt;cv::Vec2f&gt;(i, j)[<span class="number">0</span>], funcH.at&lt;cv::Vec2f&gt;(i, j)[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">		g *= h;</span><br><span class="line"></span><br><span class="line">		fOrigin.at&lt;cv::Vec2f&gt;(i, j)[<span class="number">0</span>] = g.real();</span><br><span class="line">		fOrigin.at&lt;cv::Vec2f&gt;(i, j)[<span class="number">1</span>] = g.imag();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do IFFT</span></span><br><span class="line">cv::Mat matRes = grayImageIFFT(fOrigin);</span><br><span class="line">cv::Mat result = cv::Mat(matRes, cv::Rect(<span class="number">0</span>, <span class="number">0</span>, origin.cols, origin.rows));</span><br></pre></td></tr></table></figure>
<p>以上代码算半个伪代码，完成了普通的频域相乘操作。如果要做其它的操作（比如维纳滤波），改循环里的公式就行了。</p>
<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><p>同<a href="https://zhouyifan.net/2019/12/26/Digital-Image-Processing-homework1/#structure">上次任务</a>。</p>
<p>其中图像处理分成两个模块：退化图像生成与退化图像修复。</p>
<p>退化图像生成又分两个模块：模糊和加噪声。</p>
<p>最终实现的时候又加了一个交互模块，可以动态调参。这个模块要调用退化图像生成模块和退化图像修复模块。模块化设计的好处在这里就体现出来了。</p>
<p>虽然我感觉我模块分得特别好，最终代码清晰简明，符合数据流的内在逻辑结构，但我还是不太想在这里炫耀了。</p>
<h2 id="程序设计心路历程"><a href="#程序设计心路历程" class="headerlink" title="程序设计心路历程"></a>程序设计心路历程</h2><p>我看完高斯模糊和高斯噪声的原理后，很快就把这两部分实现了。</p>
<p>在了解原理，知道了C++有正态分布生成器后，这部分应该非常容易实现。</p>
<p>先提一句，最开始高斯模糊卷积我是直接拿<code>filter2D</code>做的。</p>
<p>问题就出在维纳滤波上。</p>
<p>一开始，我把原图像做了FFT，卷积核直接做了FFT再扩展到和原图像同样大小，再逐像素用公式计算，最后把计算结果IFFT。最终，我得到了一幅乱七八糟的图像。</p>
<p>频域的操作难以可视化，难以调试。我甚至都不知道我哪一步错了。但是，我凭借着我冷静的大脑，准备把这个过程逐一调试。</p>
<p>首先，我打算验证FFT和IFFT是否正确。我对一个图像进行FFT再IFFT回来，发现图像没有复原。果然，FFT和IFFT这步我就做错了。为了解决这个问题，我查了好多东西，还瞎照网上写了个FFT的优化函数。最后我理解了一下<code>cv::dft</code>的参数的含义，才把FFT和IFFT做对。</p>
<p>接着，我开始怀疑我的卷积核是不是不太对。FFT的原点在左上角，而卷积核的原点在中间，这好像不太对劲。但我一时半会儿解决不了这个问题。于是我干脆把卷积核的原点改到了左上角，即每次卷积的时候只对右下角的部分卷积，忽略掉这个问题，先解决其他问题。</p>
<p>我现在想验证除了卷积核外，我整个维纳滤波公式的运算是否有问题。我知道，如果没有噪声的话，逆滤波可以直接把图像复原，此时维纳滤波k值取0。因此，我暂时去掉了噪声，把k值设成0，看算法效果如何。结果图像确实复原出来了，但四周有一些不和谐的条状噪声。这个结果搞得我一头雾水。</p>
<p>我进一步思考，逆滤波能够复原图像，是因为噪声卷积操作和逆变换互为逆操作。但我卷积是拿<code>filter2D</code>做的，逆变换是在频域做的，这二者会不会工作原理不一样？于是，我暂时把卷积操作也变成频域操作。</p>
<p>终于，经过我这次的瞎折腾后，露娜sama美丽的面庞终于清晰地出现在了屏幕上。我又对退化图像加上了噪声。这次，k值取0的时候画面一片模糊，但k值只要稍稍增大，依旧能生成较退化图像更清晰的复原图像。至此，调试第一阶段结束，我高兴了好一会儿。</p>
<p>顺带一提，这个阶段为了调试方便，我把调k值放进了GUI里面，这样可以动态看到调参的结果。由于Debug模式下性能捉鸡，我又把OpenCV的Release版本编译了一遍。</p>
<p>问题是，现在我忽略了两个问题，一个是卷积核中心位置的问题，一个是用<code>Filter2D</code>的问题。我准备先解决第一个问题。</p>
<p>我把卷积核的原点又放回了中心。这次修改后，复原图像倒是能够生成了，但是图像的位置完全乱了：图像的左上角在右下角，右下角在左上角……。整个图像的四周都颠倒了。我去写了个OpenCV的<code>fft2shift</code>，试图把图像移正。但移正之后发现图像复原是失败的，最终图像和退化图像长得差不多。</p>
<p>在反复阅读了网上的代码后，我发现我代码唯一不太对的地方就是少了个<code>psf2otf</code>函数。我去搜了一下这个函数，竟然惊喜地搜到了这个函数的C++实现。我赶紧学了一下，看懂了函数的工作原理。我把这个函数加入了代码中，但怎么调都调不对。无奈之下，我只好双手离开键盘，选择冷静思考一波。</p>
<p>吃饭的时候，我仔细想了一想FFT的原理。我通过我以前对一维FFT的认识，以及昨天搜索到的零碎知识，渐渐搞清了<code>psf2otf</code>的原理以及目的。原来，图像FFT溢出的部分会“往回填”，图像靠右的部分表示的是负频率。为了保证卷积操作的正确进行，卷积核也要在扩充至和图像一样大小后，循环移动到左上角。</p>
<p>理清楚了每一条逻辑后，我修改了代码，在卷积核原点在中心时，图像终于能够正常地复原了。</p>
<p>最后是<code>Filter2D</code>的问题。如果卷积操作是拿这个函数做，得到的复原图像四周就会有条纹。我开始分析这种问题出现的原因。从“只有四周有问题”这个事实上，我想到很可能是<code>Filter2D</code>对边界处理的方式和用FFT处理不同。FFT是把整幅图像当成一个循环的图像来处理，因此会出现最右边像素受到最左边的像素的影响这种问题。而<code>Filter2D</code>对边界的处理有多种方式。我查了一下函数说明，果然<code>Filter2D</code>默认是把边缘反射处理，和在频域运算的方法不相同。但我尝试把边缘循环处理的时候，函数却报错了。源代码Assert掉了循环处理，不允许使用。无奈之下，我只好不使用<code>Filter2D</code>。反正我已经完全理解了这些操作的细节了。</p>
<p>最终程序的详细内容我就不讲了。感觉这份程序结构化做得非常棒，功能实现得非常完全。由于是作业，我还不得不加上了很多注释。相信大部分人都能看懂我那清晰易懂的代码。具体代码可以去代码仓库查看。</p>
<h2 id="处理结果"><a href="#处理结果" class="headerlink" title="处理结果"></a>处理结果</h2><p><img src="//zhouyifan.net/2019/12/30/Digital-Image-Processing-homework2/I_o.jpg" alt></p>
<p>原图</p>
<p><img src="//zhouyifan.net/2019/12/30/Digital-Image-Processing-homework2/I_n.jpg" alt></p>
<p>噪声图</p>
<p><img src="//zhouyifan.net/2019/12/30/Digital-Image-Processing-homework2/I_d.jpg" alt></p>
<p>修复结果</p>
<p>附原图的彩图版本：</p>
<p><img src="//zhouyifan.net/2019/12/30/Digital-Image-Processing-homework2/origin.jpg" alt></p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>这个作业实在是太烦人了。原来我以为一个下午就能做完的东西，硬是做了两天。</p>
<p>我遇到的问题实在是有些令人恼火。我既不是程序代码不会写，也不是算法原理没搞懂，而是API怎么调，某个操作的实现细节这些边界知识没有掌握。本次作业没增加多少我对复原算法的认识，倒是进一步强化了我搜索信息和理解信息的能力。</p>
<p>之前，包括课本在内，很多介绍模糊和复原的文章都在用一个女性照片做为原图像。我一开始还没明白为什么。后来，在写程序碰到瓶颈之余，我好好分析了一下这个问题，总算得到了一个非常漂亮的结论：科研工作者大多为单身男性，每日面对的只有无情的代码和冷冰冰的文字。在这种恶劣的条件下，偶尔出现的女性照片，能给你黯淡的内心点上一丝救赎的光芒。所以，人们更多地选择那张女性照片。</p>
<p>可惜我的内心对于这种照片不为所动。我想，凭什么只用三次元的照片？于是，我随便在电脑里找了一张露娜sama的图片。果然，看着这幅CG被一步一步复原，我被各种BUG蹂躏得受伤的心灵得到了安慰。我为自己的机智和随机应变能力而赞叹不已。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2019/12/26/Digital-Image-Processing-homework1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/26/Digital-Image-Processing-homework1/" class="post-title-link" itemprop="url">数字图像处理小作业1：RGB转CMY转HCI及简单风格化（附OpenCV安装及基本使用方法）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-26 15:11:59" itemprop="dateCreated datePublished" datetime="2019-12-26T15:11:59+08:00">2019-12-26</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Study/Computer-Science/Digital-Image-Processing/" itemprop="url" rel="index"><span itemprop="name">Digital Image Processing</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数字图像处理小作业1"><a href="#数字图像处理小作业1" class="headerlink" title="数字图像处理小作业1"></a>数字图像处理小作业1</h1><p>最近软件工程课要我们用博客记录项目。我感觉这样做挺好的，一来可以让项目的开发更规范化，二来可以给博客和github添加一些内容，不让大学生活看起来很空虚。以后我所有项目作业尽量都建立仓库和博客。</p>
<h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><p><a href="https://github.com/SingleZombie/RGB-CMY-HSI-transformer-homework" target="_blank" rel="noopener">https://github.com/SingleZombie/RGB-CMY-HSI-transformer-homework</a></p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul>
<li>原图像一张RGB（彩色图像）</li>
<li>分别在RGB，CMY，和HSI三个空间通过调整颜色实现一种风格化转换（风格自选）</li>
<li>需要提交源码以及不超过半页的代码说明(说明使用的库和参数)</li>
<li>压缩包内文件命名方式为:<br>  -图像命名：<br>  0(此原图像)<br>  1RGB,2CMY,3HSI（此为处理结果）<br>  -文档命名：学号_姓名_1<br>  -代码包命名：学号_姓名_1</li>
</ul>
<p>以上是老师给的作业要求。据说老师上课的时候还提到，三种通道的风格化结果要看起来相等。</p>
<p>我对风格化的理解是，改变某种彩色表示下某个分量后得到的结果。</p>
<p>经总结，需求有以下内容：</p>
<ul>
<li>实现RGB到CMY和HSI的转换</li>
<li>在某种表示下改变图片风格，并调整另两种表示下的结果使得图片看起来相同</li>
<li>写说明文档</li>
</ul>
<h2 id="技术学习"><a href="#技术学习" class="headerlink" title="技术学习"></a>技术学习</h2><h3 id="OpenCV入门"><a href="#OpenCV入门" class="headerlink" title="OpenCV入门"></a>OpenCV入门</h3><h4 id="OpenCV安装与配置"><a href="#OpenCV安装与配置" class="headerlink" title="OpenCV安装与配置"></a>OpenCV安装与配置</h4><p>在本作业中，我打算用OpenCV来读、写、显示图像文件。在一些任务开始前，我要先学OpenCV的用法。</p>
<p>我是在Win10下用VS2017编程，生成的是x86程序。</p>
<ul>
<li>去 <a href="https://opencv.org/releases/" target="_blank" rel="noopener">https://opencv.org/releases/</a> 下载Windows版本的库文件。下载后能得到一个exe文件，把该文件“解压”到一个路径即可。解压的文件夹里有一个opencv子文件夹。记此子文件夹为<code>$(OPENCV)</code>。</li>
<li><p>x86的OpenCV库编译（可选）</p>
<ol>
<li>去<a href="https://opencv.org/releases/" target="_blank" rel="noopener">https://opencv.org/releases/</a> 下载Sources，这样编译出来的库可以满足当前编译器的配置。（直接安装的话没有x86的文件）</li>
<li>用cmake配置源代码。注意源代码的路径最好不要包含中文。（我第一次包含了中文，结果vs编译到一半出错了）</li>
<li>用vs打开cmake生成的目录下的OpenCV.sln，编译源代码。</li>
<li>编译结束后在目录的lib文件夹中找到编译的结果文件夹(Debug或Release)，里面所有.lib文件就是编译的结果，把它们放到上一步的build文件夹里。我按照格式放到了<code>$(OPENCV)\build\x86\vc15\lib</code>文件夹里。</li>
<li>编译出的bin文件夹需要加入系统环境变量，因为里面的dll会被用到。改完环境变量重启电脑。</li>
</ol>
</li>
<li>在VS中的属性管理器新建配置，添加用户宏OPENCV，宏值就是开始那个解压出的opencv子文件夹。<code>$(OPENCV)</code>现在就表示库目录了。</li>
<li>在属性的包含目录里加上<code>$(OPENCV)\build\include</code>，库目录改成对应版本的库的目录，比如我的就是<code>$(OPENCV)\build\x86\vc15\lib</code>。</li>
<li>VS链接器-输入-附加依赖项中加入需要的.lib文件。我的第一个程序加入了opencv_highgui420d.lib;opencv_core420d.lib;opencv_imgcodecs420d.lib这三个库</li>
<li>我随便到网上找了下函数，依葫芦画瓢地写了以下代码。如果一切都配置好了，程序会显示main.cpp目录下wallpaper.jpg这张图片。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> windowName = <span class="string">"window1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cv::Mat mat = cv::imread(<span class="string">"wallpaper.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	cv::namedWindow(windowName);</span><br><span class="line">	cv::imshow(windowName, mat);</span><br><span class="line"></span><br><span class="line">	cv::waitKey();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="OpenCV-像素获取与修改"><a href="#OpenCV-像素获取与修改" class="headerlink" title="OpenCV 像素获取与修改"></a>OpenCV 像素获取与修改</h4><p>OpenCV的操作很多都基于<code>Mat</code>的对象，也就是图像矩阵。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R, G, B;</span><br><span class="line">B = mat.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">0</span>];</span><br><span class="line">G = mat.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">1</span>];</span><br><span class="line">R = mat.at&lt;cv::Vec3b&gt;(i, j)[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>对矩阵的at操作可以get或set颜色分量的值。</p>
<p>注意RGB是反的。</p>
<h4 id="OpenCV输入输出图像"><a href="#OpenCV输入输出图像" class="headerlink" title="OpenCV输入输出图像"></a>OpenCV输入输出图像</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat mat = cv::imread(<span class="string">"in.png"</span>);</span><br><span class="line">cv::imwrite(<span class="string">"out.png"</span>, mat);</span><br></pre></td></tr></table></figure>
<p>输入输出都是基于<code>Mat</code>的对象。</p>
<h3 id="RGB转CMY、HSI"><a href="#RGB转CMY、HSI" class="headerlink" title="RGB转CMY、HSI"></a>RGB转CMY、HSI</h3><h4 id="RGB转CMY"><a href="#RGB转CMY" class="headerlink" title="RGB转CMY"></a>RGB转CMY</h4><p>看了一下，RGB符合人对颜色的认知。但现实中，为了方便打印出黑色，用CMY表示颜料的颜色更加方便。</p>
<p>CMY就是RGB取反，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C = 255 - R;</span><br><span class="line">M = 255 - G;</span><br><span class="line">Y = 255 - B;</span><br></pre></td></tr></table></figure>
<h4 id="RGB转HSI"><a href="#RGB转HSI" class="headerlink" title="RGB转HSI"></a>RGB转HSI</h4><p>我对HSI的大致理解是：H是颜色的属性，比如是红色、绿色、蓝色还是其他颜色；S是颜色被稀释的属性，也就是颜色的深浅；I是光强，是颜色向量的模的大小。</p>
<p><a href="https://blog.csdn.net/yangleo1987/article/details/53171623" target="_blank" rel="noopener">https://blog.csdn.net/yangleo1987/article/details/53171623</a> 里有好几个RGB转HSI方法的介绍。其中第一种是上课提到的方法。</p>
<h3 id="风格转换"><a href="#风格转换" class="headerlink" title="风格转换"></a>风格转换</h3><p>我问了一下别人，又看了一下书。感觉风格转换就是对某个颜色通道做一个函数映射，使得图片整体风格改变。</p>
<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计 "></a>结构设计 <div id="structure"></div></h2><p>由于程序过于简单，该程序用结构化的设计方法。</p>
<p>输入经过输入预处理模块，进入处理模块，最后进入输出模块输出。整个结构非常简明而无趣。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//         ******************    ***********************    *******************</span><br><span class="line">// data -&gt; ** input module ** -&gt; ** processing module ** -&gt; ** output module ** -&gt; output</span><br><span class="line">//         ******************    ***********************    *******************</span><br></pre></td></tr></table></figure>
<p>由于要提交源代码文件，我把代码全部放到一个main.cpp里面了。但在我心中，还是为每个模块各建了一个头文件和cpp文件的。</p>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="程序概览"><a href="#程序概览" class="headerlink" title="程序概览"></a>程序概览</h3><p>代码放在Github上：<a href="https://github.com/SingleZombie/RGB-CMY-HSI-transformer-homework" target="_blank" rel="noopener">代码仓库</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cv::Mat mat = getInput(<span class="string">"0.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> matArr = processImage(mat);</span><br><span class="line"></span><br><span class="line">	outputImage(matArr[<span class="number">0</span>], <span class="string">"1RGB.jpg"</span>);</span><br><span class="line">	outputImage(matArr[<span class="number">1</span>], <span class="string">"2CMY.jpg"</span>);</span><br><span class="line">	outputImage(matArr[<span class="number">2</span>], <span class="string">"3HSI.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	cv::imshow(<span class="string">"w1"</span>, matArr[<span class="number">0</span>]);</span><br><span class="line">	cv::imshow(<span class="string">"w2"</span>, matArr[<span class="number">1</span>]);</span><br><span class="line">	cv::imshow(<span class="string">"w3"</span>, matArr[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">	cv::waitKey();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数非常简明，<code>getInput</code>和<code>outputImage</code>隐藏了输入输出细节，方便修改。事实上，图像读入时像素是用unsigned char存储的，我在输入的时候把它转换成了float，输出的时候又转了回去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat.cols; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// tranformation</span></span><br><span class="line">		matCMY.at&lt;cv::Vec3f&gt;(i, j) = bgrToYmc(matCMY.at&lt;cv::Vec3f&gt;(i, j));</span><br><span class="line">		matHSI.at&lt;cv::Vec3f&gt;(i, j) = bgrToHsi(matHSI.at&lt;cv::Vec3f&gt;(i, j));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// tonal function</span></span><br><span class="line">		<span class="comment">// ........</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="comment">// inverse transformation</span></span><br><span class="line">		matCMY.at&lt;cv::Vec3f&gt;(i, j) = ymcToBgr(matCMY.at&lt;cv::Vec3f&gt;(i, j));</span><br><span class="line">		matHSI.at&lt;cv::Vec3f&gt;(i, j) = hsiToBgr(matHSI.at&lt;cv::Vec3f&gt;(i, j));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>processImage</code>的主体是遍历像素，先把原图像做格式转换，再用自己的风格转换函数瞎搞，最后转换回正常的格式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> cv::<span class="function">Vec3f <span class="title">bgrToYmc</span><span class="params">(<span class="keyword">const</span> cv::Vec3f&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cv::Vec3f(<span class="number">1.0f</span> - vec[<span class="number">0</span>], <span class="number">1.0f</span> - vec[<span class="number">1</span>], <span class="number">1.0f</span> - vec[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> cv::<span class="function">Vec3f <span class="title">ymcToBgr</span><span class="params">(<span class="keyword">const</span> cv::Vec3f&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cv::Vec3f(<span class="number">1.0f</span> - vec[<span class="number">0</span>], <span class="number">1.0f</span> - vec[<span class="number">1</span>], <span class="number">1.0f</span> - vec[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> cv::<span class="function">Vec3f <span class="title">bgrToHsi</span><span class="params">(<span class="keyword">const</span> cv::Vec3f&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> R = vec[<span class="number">2</span>], G = vec[<span class="number">1</span>], B = vec[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">float</span> RG = (R - G), RB = (R - B);</span><br><span class="line">	<span class="keyword">float</span> tmp = <span class="built_in">sqrt</span>(RG * RG + RB * (G - B)); <span class="comment">// 分母不能为0！！！</span></span><br><span class="line">	<span class="keyword">float</span> theta = tmp != <span class="number">0</span> ? <span class="built_in">acos</span>(<span class="number">0.5f</span> * (RG + RB) / tmp) : <span class="number">0</span>;</span><br><span class="line">	theta = B &gt; G + EPS ? CV_2PI - theta : theta;</span><br><span class="line">	<span class="keyword">return</span> cv::Vec3f(</span><br><span class="line">		theta / CV_2PI,</span><br><span class="line">		<span class="number">1.0f</span> - <span class="number">3.0f</span> * <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(R, G), B) / (R + G + B),</span><br><span class="line">		(R + G + B) / <span class="number">3.0f</span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> cv::<span class="function">Vec3f <span class="title">hsiToBgr</span><span class="params">(<span class="keyword">const</span> cv::Vec3f&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> H = vec[<span class="number">0</span>] * CV_2PI, S = vec[<span class="number">1</span>], I = vec[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">float</span> H2 = <span class="built_in">fmod</span>(H, CV_2PI / <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">float</span> v1 = I * (<span class="number">1.0f</span> - S);</span><br><span class="line">	<span class="keyword">float</span> v2 = I * (<span class="number">1.0f</span> + S * <span class="built_in">cos</span>(H2) / <span class="built_in">cos</span>(CV_PI / <span class="number">3</span> - H2));</span><br><span class="line">	<span class="keyword">float</span> v3 = <span class="number">3</span> * I - v1 - v2;</span><br><span class="line">	<span class="keyword">if</span> (H + EPS &lt; CV_2PI / <span class="number">3.0f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> cv::Vec3f(v1, v3, v2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (H + EPS &lt; <span class="number">2.0f</span> * CV_2PI / <span class="number">3.0f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> cv::Vec3f(v3, v2, v1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> cv::Vec3f(v2, v1, v3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>格式转换函数完全是在照搬公式而已，没有什么价值。</p>
<h3 id="写程序过程中碰到的问题"><a href="#写程序过程中碰到的问题" class="headerlink" title="写程序过程中碰到的问题"></a>写程序过程中碰到的问题</h3><ol>
<li>为了公式处理方便，我把像素格式转换成了float。我一开始以为直接就能通过<code>mat.at&lt;Vec3f&gt;</code>来访问浮点格式像素，但是发现<code>cv::Mat</code>的机制好像是只能允许像素按一种格式存。要把图像矩阵用<code>.convertTo(mat, CV_32FC3, 1 / 255.0)</code>来转换成浮点表示，最后输出的时候还要用<code>.convertTo(tmpMat, CV_8UC3, 255.0f)</code>转换回去。</li>
<li>我还好提前看了一下<code>cv::Mat</code>的工作原理。该类只存了图像数据的指针，要复制图像数据的话要调用<code>src.copyTo(dest)</code></li>
<li>图片转HSI再转回来后，我发现图像中出现一些绿色方块。经调试发现，H分量在运算的时候变成了nan。计算H的时候一定要判断分母是否为0！</li>
<li>图像的RGB是倒着存的。我之前测试OpenCV的时候碰到了这个问题，写这个程序的时候就跳过了这个坑。</li>
</ol>
<h2 id="处理结果"><a href="#处理结果" class="headerlink" title="处理结果"></a>处理结果</h2><p><img src="//zhouyifan.net/2019/12/26/Digital-Image-Processing-homework1/0.jpg" alt="0.jpg"></p>
<p>原图 </p>
<p><img src="//zhouyifan.net/2019/12/26/Digital-Image-Processing-homework1/1RGB.jpg" alt="1.jpg"></p>
<p>RGB风格转换结果</p>
<p><img src="//zhouyifan.net/2019/12/26/Digital-Image-Processing-homework1/2CMY.jpg" alt="2.jpg"></p>
<p>CMY风格转换结果</p>
<p><img src="//zhouyifan.net/2019/12/26/Digital-Image-Processing-homework1/3HSI.jpg" alt="3.jpg"></p>
<p>HSI风格转换结果</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>写博客真浪费时间。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zhou Yifan</p>
              <p class="site-description motion-element" itemprop="description">A foresighted strategist with big-picture thinking. 大局观选手。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Yifan</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.0.1</div>




<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>




  

  


  <script src="/js/src/bootstrap.js?v=7.0.1"></script>


  
  



  




  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow-x: scroll;
  overflow-y: hidden;
}
</style>

    
  


  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

</body>
</html>
